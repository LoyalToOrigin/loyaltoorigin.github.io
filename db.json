{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1530152448305},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1530176371557},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1530176371558},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1530176371559},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1530176371558},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1530176371560},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1530176371561},{"_id":"themes/next/README.md","hash":"c1d6d1c6b75736b892e179865833ea58da5ca9d2","modified":1530176371561},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1530176371561},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1530176371561},{"_id":"themes/next/_config.yml","hash":"0169e67a3800ac7cee752a8aa6df719609e59616","modified":1530176371562},{"_id":"themes/next/bower.json","hash":"a8c832da6aad5245052aed7ff26c246f85d68c6c","modified":1530176371562},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1530176371563},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1530176371570},{"_id":"themes/next/package.json","hash":"11a0b27f92da8abf1efbea6e7a0af4271d7bff9e","modified":1530176371597},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1530176658539},{"_id":"source/_posts/iOS自动化打包之重签名导出不同证书ipa探索.md","hash":"7a4c1754f1c0c1a5e527d25d24fd59f44279f193","modified":1530151680277},{"_id":"source/_posts/关于iOS自动化打包的一些分享.md","hash":"9fb59a93042632cf8ff1ede03c1df128507248f6","modified":1530152420105},{"_id":"source/_posts/通过Method运行时内存布局hook方法探索.md","hash":"3808925720edbc1d33d38b4ed86fc098974f0621","modified":1530336092900},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1530176371550},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1530176371552},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1530176311847},{"_id":"themes/next/.git/index","hash":"07db6b8cbfcb2d241162f866e54e0949bc8ab2ee","modified":1530176658503},{"_id":"themes/next/.git/packed-refs","hash":"9744dd6a466d9ee55e9c64d4c94f98a3a5392e98","modified":1530176371548},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1530176371559},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"f846118d7fc68c053df47b24e1f661241645373f","modified":1530176371559},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1530176371560},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1530176371559},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1530176371560},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1530176371560},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1530176371563},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1530176371564},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1530176371564},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1530176371564},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1530176371564},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1530176371565},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1530176371565},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1530176371565},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1530176371566},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1530176371571},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1530176371571},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1530176371571},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1530176371572},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1530176371572},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1530176371572},{"_id":"themes/next/languages/ja.yml","hash":"5f8e54c666393d1ca2e257f6b1e3b4116f6657d8","modified":1530176371573},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1530176371573},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1530176371573},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1530176371574},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1530176371574},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1530176371574},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1530176371575},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1530176371576},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1530176371577},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1530176371577},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1530176371578},{"_id":"themes/next/layout/_layout.swig","hash":"09e8a6bfe5aa901c66d314601c872e57f05509e8","modified":1530176371579},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1530176371596},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1530176371596},{"_id":"themes/next/layout/index.swig","hash":"53300ca42c00cba050bc98b0a3f2d888d71829b1","modified":1530176371596},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1530176371596},{"_id":"themes/next/layout/post.swig","hash":"e7458f896ac33086d9427979f0f963475b43338e","modified":1530176371597},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1530176371597},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1530176371597},{"_id":"themes/next/scripts/helpers.js","hash":"4cc592788f088a99dd1d70875e8344b6e16cc34d","modified":1530176371598},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1530176371598},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1530176371598},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1530176371678},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1530176371679},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1530176371679},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371636},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1530176311849},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1530176311847},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1530176311850},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1530176311851},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1530176311849},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1530176311851},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1530176311848},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1530176311849},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1530176311850},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1530176311851},{"_id":"themes/next/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1530176311846},{"_id":"themes/next/.git/logs/HEAD","hash":"f634cd7d468ec5f18748e1c9aa64ec48bc9db764","modified":1530176371551},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1530176371566},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1530176371566},{"_id":"themes/next/docs/ru/README.md","hash":"edfe0cfb8b2c9f0effd3beb868af9bfd0fabb3a6","modified":1530176371567},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1530176371567},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1530176371567},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1530176371568},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"44e4fb7ce2eca20dfa98cdd1700b50d6def4086f","modified":1530176371568},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1530176371568},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1530176371569},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1530176371569},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1530176371569},{"_id":"themes/next/docs/zh-CN/README.md","hash":"46b264623af21211a0a9c4ba0cf1318a80eeb9fb","modified":1530176371570},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1530176371570},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1530176371578},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1530176371578},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1530176371579},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1530176371580},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1530176371580},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1530176371580},{"_id":"themes/next/layout/_macro/post.swig","hash":"686e60ede86547bdd7bc34c3629e4c9dbd134a21","modified":1530176371581},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1530176371581},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1530176371581},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1530176371581},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1530176371581},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1530176371582},{"_id":"themes/next/layout/_partials/footer.swig","hash":"cf8fe76993b513b97f379832222b6ec7e41a1c15","modified":1530176371582},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1530176371584},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1530176371584},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1530176371585},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1530176371586},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1530176371586},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1530176371587},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1530176371589},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1530176371591},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1530176371591},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1530176371591},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1530176371592},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1530176371592},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1530176371593},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1530176371593},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1530176371593},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1530176371599},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1530176371599},{"_id":"themes/next/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1530176371599},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1530176371599},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1d59b968af4b8d147f8bc9bc295d596e41be8348","modified":1530176371599},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"545102e3aa3ce494f7046abf71cefb7aaf671559","modified":1530176371600},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1530176371600},{"_id":"themes/next/scripts/tags/note.js","hash":"265dc7ee83d3fe317e88058e80aa8170230a005e","modified":1530176371600},{"_id":"themes/next/scripts/tags/tabs.js","hash":"6bdf2a1a23cb9922fa809c79af3b06339c28cd70","modified":1530176371600},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1530176371636},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530176371637},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530176371637},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1530176371637},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1530176371637},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1530176371638},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1530176371638},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1530176371638},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1530176371638},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1530176371639},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1530176371639},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530176371639},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530176371639},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530176371640},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530176371640},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530176371640},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1530176371640},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1530176371641},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1530176371641},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371586},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371586},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371629},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371630},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371630},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371636},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530176371636},{"_id":"themes/next/.git/refs/heads/master","hash":"5ae04e48ec130c5575779115eb91595455609755","modified":1530176371551},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1530176371579},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1530176371580},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1530176371582},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1530176371582},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1530176371582},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1530176371583},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1530176371583},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1530176371583},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1530176371583},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1530176371584},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1530176371584},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1530176371584},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1530176371584},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1530176371585},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1530176371585},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1530176371585},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1530176371585},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1530176371586},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1530176371586},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1530176371586},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1530176371587},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1530176371587},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1530176371587},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1530176371588},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1530176371587},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1530176371588},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1530176371588},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1530176371588},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1530176371588},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"cee047575ae324398025423696b760db64d04e6f","modified":1530176371589},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1530176371589},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1530176371589},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1530176371589},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1530176371589},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"8878241797f8494a70968756c57cacdfc77b61c7","modified":1530176371590},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1530176371590},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1530176371590},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1530176371590},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1530176371590},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1530176371591},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1530176371591},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1530176371592},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1530176371592},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1530176371592},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1530176371594},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1530176371594},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1530176371595},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1530176371595},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1530176371629},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1530176371629},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1530176371630},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1530176371630},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1530176371635},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1530176371635},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"66fd28196b8c2ffaddda27e66c4cf4428d7a12ce","modified":1530176371636},{"_id":"themes/next/source/css/_variables/base.styl","hash":"04d0daf587243a983754876fe2928070c3e3b2a8","modified":1530176371636},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1530176371642},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1530176371642},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1530176371642},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1530176371643},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1530176371643},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1530176371644},{"_id":"themes/next/source/js/src/motion.js","hash":"4726b2cf26e9aebb56cf607905471f3acbd690ae","modified":1530176371644},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1530176371645},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1530176371645},{"_id":"themes/next/source/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1530176371646},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1530176371646},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1530176371646},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1530176371647},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1530176371647},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1530176371647},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1530176371656},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1530176371656},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1530176371657},{"_id":"themes/next/.git/objects/pack/pack-1d84966bee63f964549e530d73fbddefbbbac852.idx","hash":"eabe6040da0b3cbc8dad2a7bb7180732596507a5","modified":1530176371533},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1530176371653},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"f634cd7d468ec5f18748e1c9aa64ec48bc9db764","modified":1530176371551},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1530176371550},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1530176371593},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1530176371593},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1530176371626},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1530176371601},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1530176371601},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1530176371601},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1530176371601},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1530176371602},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1530176371606},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1530176371619},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1530176371627},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1530176371627},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1530176371627},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1530176371628},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1530176371628},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1530176371628},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1530176371630},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1530176371631},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1530176371631},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1530176371631},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1530176371631},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1530176371631},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1530176371632},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1530176371632},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1530176371634},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1530176371634},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1530176371634},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1530176371634},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1530176371635},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1530176371635},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1530176371635},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1530176371633},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1530176371633},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1530176371633},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1530176371633},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1530176371633},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1530176371645},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1530176371648},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1530176371648},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1530176371648},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1530176371653},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1530176371654},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1530176371651},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1530176371651},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1530176371655},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"f634cd7d468ec5f18748e1c9aa64ec48bc9db764","modified":1530176371549},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1530176371602},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1530176371602},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1530176371602},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1530176371603},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1530176371603},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1530176371603},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1530176371604},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1530176371604},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1530176371603},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1530176371605},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1530176371604},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1530176371605},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1530176371605},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1530176371605},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1530176371606},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1530176371606},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1530176371606},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1530176371607},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1530176371607},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1530176371607},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1530176371608},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1530176371608},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1530176371607},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1530176371609},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1530176371609},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1530176371609},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1530176371611},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1530176371611},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1530176371610},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1530176371609},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1530176371612},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1530176371613},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"bbe0d111f6451fc04e52719fd538bd0753ec17f9","modified":1530176371614},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1530176371614},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1530176371615},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1530176371615},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1530176371616},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1530176371616},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1530176371618},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1530176371618},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1530176371619},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1530176371617},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"cf2185a0ea170fd8450f592e859a6c941141e5ee","modified":1530176371620},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1530176371620},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1530176371620},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1530176371621},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1530176371621},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1530176371622},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1530176371621},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1530176371622},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1530176371622},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1530176371623},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1530176371623},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1530176371624},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1530176371624},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1530176371624},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1530176371625},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1530176371625},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1530176371625},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1530176371625},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1530176371626},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1530176371632},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1530176371632},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1530176371634},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1530176371650},{"_id":"themes/next/.git/objects/pack/pack-1d84966bee63f964549e530d73fbddefbbbac852.pack","hash":"53c3d677e0e604102fd2c3e3363098d89b20c8f0","modified":1530176371531},{"_id":"public/archives/index.html","hash":"eacce7a46a790f2c9cf486cb5b036b415db4c8d4","modified":1530336575052},{"_id":"public/archives/2018/index.html","hash":"378427d5d92b7489b7dc29d09265a1aaba0804bd","modified":1530336575052},{"_id":"public/archives/2018/01/index.html","hash":"441cc6556d1034292671cebc043cd054cd614c72","modified":1530336575052},{"_id":"public/archives/2018/03/index.html","hash":"0a00a114d7337cab382d463aca787ad0daef29f7","modified":1530336575052},{"_id":"public/archives/2018/06/index.html","hash":"974faf3f77b2fd364f4f40fed91e8c26524ee867","modified":1530336575052},{"_id":"public/2018/06/30/通过Method运行时内存布局hook方法探索/index.html","hash":"b6b6742024911e687ad42ee481ad69a75be5cd63","modified":1530336575052},{"_id":"public/2018/03/08/iOS自动化打包之重签名导出不同证书ipa探索/index.html","hash":"ac8b68f7216e01268e4cae2b5c2a0e33c9bdfb8e","modified":1530336575052},{"_id":"public/2018/01/11/关于iOS自动化打包的一些分享/index.html","hash":"be6aea0151d1f7f65cd2bd25d75797f283a34441","modified":1530336575053},{"_id":"public/index.html","hash":"b46068d289f21886c9e06a5c72197256bf92331d","modified":1530336575053},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1530336575058},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1530336575058},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1530336575058},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1530336575058},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1530336575058},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1530336575058},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1530336575059},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1530336575059},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1530336575059},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1530336575059},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1530336575059},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1530336575059},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530336575059},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1530336575059},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1530336575059},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1530336575059},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1530336575059},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1530336575059},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1530336575059},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1530336575060},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1530336575543},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1530336575554},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1530336575563},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1530336575563},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1530336575563},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1530336575563},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1530336575563},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1530336575563},{"_id":"public/js/src/motion.js","hash":"4726b2cf26e9aebb56cf607905471f3acbd690ae","modified":1530336575563},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1530336575563},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1530336575563},{"_id":"public/js/src/utils.js","hash":"e829806d054991d0324a339993082206ca6026e5","modified":1530336575563},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1530336575563},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1530336575563},{"_id":"public/js/src/schemes/pisces.js","hash":"ab6f13fae0513a9b39f8d8c4c3a4e3928014f046","modified":1530336575563},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1530336575563},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1530336575563},{"_id":"public/css/main.css","hash":"3124e1cabc5b5e5ad371ff7a45445c776100ae72","modified":1530336575563},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1530336575563},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1530336575563},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1530336575563},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1530336575563},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1530336575564},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1530336575564},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1530336575564}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"iOS自动化打包之重签名导出不同证书ipa探索","date":"2018-03-07T16:00:00.000Z","_content":"\n在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。\n\n所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。\n\n我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。\n\n因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。\n\n本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。\n\n\n# 对ipa进行重签名\n\n起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。\n\n我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。\n \n\n# 不等导出ipa，修改.xcarchive文件\n\n.xcarchive文件是对项目进行手动archive，或执行以下脚本:\n\n```\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationDistribution} -archivePath ${archivePath}\n```\n\n如果对打包命令不是很了解的，可以查看我的上一篇文章文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n\n首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png)\n\n我们可以看到里面有一些App必需的属性。\n\n\n## 1. 修改 .xcarchive 的 Info.plist\n\n此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png)\n\n\n## 2. 修改 App Extension 相关信息\n\n此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 **修改主target相关信息** 。\n\n通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png)\n\n\n### 2.1 修改 Info.plist 相关信息\n\nApp Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。\n\n修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 **com.test.www** ，这里便是 **com.test.www.notificationserviceextension**。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png)\n\n### 2.2 替换 Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 2.3 修改 archived-expanded-entitlements.xcent\n\n我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，\n格式是 **teamId.bundle identifier** 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png)\n\n修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。\n\n### 2.4 重签名\n\n用对应的证书对 App Extension 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppNameNotificationServiceExtension.appex\n```\n\n\n## 3. 修改主target相关信息\n\n与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。\n\n### 3.1 修改Info.plist的相关信息\n\n进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。\n\n你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。\n\n### 3.2 替换Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 3.3 重签名\n\n用对应的证书对 .app文件 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppName.app\n```\n\n## 4. 导出包\n\n```\nxcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath\n```\n成功后，命令台输出:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png)\n\n如果对于 **exportOptionsPlist** 不了解的，也可以看我的上篇文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n。\n\n# 注意点\n\n上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。\n\n我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。\n大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。\n\n# 总结\n\n经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。\n\n\n\n\n\n","source":"_posts/iOS自动化打包之重签名导出不同证书ipa探索.md","raw":"---\ntitle: iOS自动化打包之重签名导出不同证书ipa探索\ndate: 2018-03-08\ncategories: \n---\n\n在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。\n\n所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。\n\n我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。\n\n因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。\n\n本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。\n\n\n# 对ipa进行重签名\n\n起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。\n\n我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。\n \n\n# 不等导出ipa，修改.xcarchive文件\n\n.xcarchive文件是对项目进行手动archive，或执行以下脚本:\n\n```\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationDistribution} -archivePath ${archivePath}\n```\n\n如果对打包命令不是很了解的，可以查看我的上一篇文章文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n\n首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png)\n\n我们可以看到里面有一些App必需的属性。\n\n\n## 1. 修改 .xcarchive 的 Info.plist\n\n此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png)\n\n\n## 2. 修改 App Extension 相关信息\n\n此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 **修改主target相关信息** 。\n\n通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png)\n\n\n### 2.1 修改 Info.plist 相关信息\n\nApp Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。\n\n修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 **com.test.www** ，这里便是 **com.test.www.notificationserviceextension**。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png)\n\n### 2.2 替换 Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 2.3 修改 archived-expanded-entitlements.xcent\n\n我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，\n格式是 **teamId.bundle identifier** 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png)\n\n修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。\n\n### 2.4 重签名\n\n用对应的证书对 App Extension 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppNameNotificationServiceExtension.appex\n```\n\n\n## 3. 修改主target相关信息\n\n与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。\n\n### 3.1 修改Info.plist的相关信息\n\n进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。\n\n你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。\n\n### 3.2 替换Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 3.3 重签名\n\n用对应的证书对 .app文件 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppName.app\n```\n\n## 4. 导出包\n\n```\nxcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath\n```\n成功后，命令台输出:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png)\n\n如果对于 **exportOptionsPlist** 不了解的，也可以看我的上篇文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n。\n\n# 注意点\n\n上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。\n\n我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。\n大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。\n\n# 总结\n\n经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。\n\n\n\n\n\n","slug":"iOS自动化打包之重签名导出不同证书ipa探索","published":1,"updated":"2018-06-28T02:08:00.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj0yvttt0000gozyt45n3gc7","content":"<p>在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。</p>\n<p>所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。</p>\n<p>我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。</p>\n<p>因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。</p>\n<p>本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。</p>\n<h1 id=\"对ipa进行重签名\"><a href=\"#对ipa进行重签名\" class=\"headerlink\" title=\"对ipa进行重签名\"></a>对ipa进行重签名</h1><p>起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。</p>\n<p>我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。</p>\n<h1 id=\"不等导出ipa，修改-xcarchive文件\"><a href=\"#不等导出ipa，修改-xcarchive文件\" class=\"headerlink\" title=\"不等导出ipa，修改.xcarchive文件\"></a>不等导出ipa，修改.xcarchive文件</h1><p>.xcarchive文件是对项目进行手动archive，或执行以下脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationDistribution&#125; -archivePath $&#123;archivePath&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对打包命令不是很了解的，可以查看我的上一篇文章文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a></p>\n<p>首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png\" alt=\"\"></p>\n<p>我们可以看到里面有一些App必需的属性。</p>\n<h2 id=\"1-修改-xcarchive-的-Info-plist\"><a href=\"#1-修改-xcarchive-的-Info-plist\" class=\"headerlink\" title=\"1. 修改 .xcarchive 的 Info.plist\"></a>1. 修改 .xcarchive 的 Info.plist</h2><p>此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png\" alt=\"\"></p>\n<h2 id=\"2-修改-App-Extension-相关信息\"><a href=\"#2-修改-App-Extension-相关信息\" class=\"headerlink\" title=\"2. 修改 App Extension 相关信息\"></a>2. 修改 App Extension 相关信息</h2><p>此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 <strong>修改主target相关信息</strong> 。</p>\n<p>通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png\" alt=\"\"></p>\n<h3 id=\"2-1-修改-Info-plist-相关信息\"><a href=\"#2-1-修改-Info-plist-相关信息\" class=\"headerlink\" title=\"2.1 修改 Info.plist 相关信息\"></a>2.1 修改 Info.plist 相关信息</h3><p>App Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。</p>\n<p>修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 <strong>com.test.www</strong> ，这里便是 <strong>com.test.<a href=\"http://www.notificationserviceextension\" target=\"_blank\" rel=\"noopener\">www.notificationserviceextension</a></strong>。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png\" alt=\"\"></p>\n<h3 id=\"2-2-替换-Provisioning-Profile\"><a href=\"#2-2-替换-Provisioning-Profile\" class=\"headerlink\" title=\"2.2 替换 Provisioning Profile\"></a>2.2 替换 Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"2-3-修改-archived-expanded-entitlements-xcent\"><a href=\"#2-3-修改-archived-expanded-entitlements-xcent\" class=\"headerlink\" title=\"2.3 修改 archived-expanded-entitlements.xcent\"></a>2.3 修改 archived-expanded-entitlements.xcent</h3><p>我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，<br>格式是 <strong>teamId.bundle identifier</strong> 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png\" alt=\"\"></p>\n<p>修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。</p>\n<h3 id=\"2-4-重签名\"><a href=\"#2-4-重签名\" class=\"headerlink\" title=\"2.4 重签名\"></a>2.4 重签名</h3><p>用对应的证书对 App Extension 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppNameNotificationServiceExtension.appex</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-修改主target相关信息\"><a href=\"#3-修改主target相关信息\" class=\"headerlink\" title=\"3. 修改主target相关信息\"></a>3. 修改主target相关信息</h2><p>与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。</p>\n<h3 id=\"3-1-修改Info-plist的相关信息\"><a href=\"#3-1-修改Info-plist的相关信息\" class=\"headerlink\" title=\"3.1 修改Info.plist的相关信息\"></a>3.1 修改Info.plist的相关信息</h3><p>进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。</p>\n<p>你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。</p>\n<h3 id=\"3-2-替换Provisioning-Profile\"><a href=\"#3-2-替换Provisioning-Profile\" class=\"headerlink\" title=\"3.2 替换Provisioning Profile\"></a>3.2 替换Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"3-3-重签名\"><a href=\"#3-3-重签名\" class=\"headerlink\" title=\"3.3 重签名\"></a>3.3 重签名</h3><p>用对应的证书对 .app文件 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppName.app</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-导出包\"><a href=\"#4-导出包\" class=\"headerlink\" title=\"4. 导出包\"></a>4. 导出包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath</span><br></pre></td></tr></table></figure>\n<p>成功后，命令台输出:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png\" alt=\"\"></p>\n<p>如果对于 <strong>exportOptionsPlist</strong> 不了解的，也可以看我的上篇文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a><br>。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。</p>\n<p>我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。<br>大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。</p>\n<p>所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。</p>\n<p>我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。</p>\n<p>因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。</p>\n<p>本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。</p>\n<h1 id=\"对ipa进行重签名\"><a href=\"#对ipa进行重签名\" class=\"headerlink\" title=\"对ipa进行重签名\"></a>对ipa进行重签名</h1><p>起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。</p>\n<p>我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。</p>\n<h1 id=\"不等导出ipa，修改-xcarchive文件\"><a href=\"#不等导出ipa，修改-xcarchive文件\" class=\"headerlink\" title=\"不等导出ipa，修改.xcarchive文件\"></a>不等导出ipa，修改.xcarchive文件</h1><p>.xcarchive文件是对项目进行手动archive，或执行以下脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationDistribution&#125; -archivePath $&#123;archivePath&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对打包命令不是很了解的，可以查看我的上一篇文章文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a></p>\n<p>首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png\" alt=\"\"></p>\n<p>我们可以看到里面有一些App必需的属性。</p>\n<h2 id=\"1-修改-xcarchive-的-Info-plist\"><a href=\"#1-修改-xcarchive-的-Info-plist\" class=\"headerlink\" title=\"1. 修改 .xcarchive 的 Info.plist\"></a>1. 修改 .xcarchive 的 Info.plist</h2><p>此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png\" alt=\"\"></p>\n<h2 id=\"2-修改-App-Extension-相关信息\"><a href=\"#2-修改-App-Extension-相关信息\" class=\"headerlink\" title=\"2. 修改 App Extension 相关信息\"></a>2. 修改 App Extension 相关信息</h2><p>此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 <strong>修改主target相关信息</strong> 。</p>\n<p>通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png\" alt=\"\"></p>\n<h3 id=\"2-1-修改-Info-plist-相关信息\"><a href=\"#2-1-修改-Info-plist-相关信息\" class=\"headerlink\" title=\"2.1 修改 Info.plist 相关信息\"></a>2.1 修改 Info.plist 相关信息</h3><p>App Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。</p>\n<p>修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 <strong>com.test.www</strong> ，这里便是 <strong>com.test.<a href=\"http://www.notificationserviceextension\" target=\"_blank\" rel=\"noopener\">www.notificationserviceextension</a></strong>。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png\" alt=\"\"></p>\n<h3 id=\"2-2-替换-Provisioning-Profile\"><a href=\"#2-2-替换-Provisioning-Profile\" class=\"headerlink\" title=\"2.2 替换 Provisioning Profile\"></a>2.2 替换 Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"2-3-修改-archived-expanded-entitlements-xcent\"><a href=\"#2-3-修改-archived-expanded-entitlements-xcent\" class=\"headerlink\" title=\"2.3 修改 archived-expanded-entitlements.xcent\"></a>2.3 修改 archived-expanded-entitlements.xcent</h3><p>我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，<br>格式是 <strong>teamId.bundle identifier</strong> 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png\" alt=\"\"></p>\n<p>修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。</p>\n<h3 id=\"2-4-重签名\"><a href=\"#2-4-重签名\" class=\"headerlink\" title=\"2.4 重签名\"></a>2.4 重签名</h3><p>用对应的证书对 App Extension 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppNameNotificationServiceExtension.appex</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-修改主target相关信息\"><a href=\"#3-修改主target相关信息\" class=\"headerlink\" title=\"3. 修改主target相关信息\"></a>3. 修改主target相关信息</h2><p>与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。</p>\n<h3 id=\"3-1-修改Info-plist的相关信息\"><a href=\"#3-1-修改Info-plist的相关信息\" class=\"headerlink\" title=\"3.1 修改Info.plist的相关信息\"></a>3.1 修改Info.plist的相关信息</h3><p>进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。</p>\n<p>你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。</p>\n<h3 id=\"3-2-替换Provisioning-Profile\"><a href=\"#3-2-替换Provisioning-Profile\" class=\"headerlink\" title=\"3.2 替换Provisioning Profile\"></a>3.2 替换Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"3-3-重签名\"><a href=\"#3-3-重签名\" class=\"headerlink\" title=\"3.3 重签名\"></a>3.3 重签名</h3><p>用对应的证书对 .app文件 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppName.app</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-导出包\"><a href=\"#4-导出包\" class=\"headerlink\" title=\"4. 导出包\"></a>4. 导出包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath</span><br></pre></td></tr></table></figure>\n<p>成功后，命令台输出:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png\" alt=\"\"></p>\n<p>如果对于 <strong>exportOptionsPlist</strong> 不了解的，也可以看我的上篇文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a><br>。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。</p>\n<p>我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。<br>大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。</p>\n"},{"title":"关于iOS自动化打包的一些分享","date":"2018-01-10T16:00:00.000Z","_content":"\n说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。\n\n即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。\n\n本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。\n\n谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。\n\n## Server相比于jenkins，我总结优点有三: \n\n1. 相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；\n2. 直接使用xcode就可开始构建项目，而不需要登录网页；\n3. 集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。\n \n这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。\n\n下面我介绍使用过程中需要注意的一些方面: \n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png)\n\n如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。\n\n如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。\n\n上面所说的plist文件大体结构是这样的:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png)\n\n这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。\n\n在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，\nhttps://192.168.0.xxx/xcode/lastest 或 https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png)\n\n\n## 关于jenkins的一些配置注意事项:\n### 以下是我在配置过程中踩到的一些坑:\n\n1. 8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；\n2. git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png)\n\n接下来，其他用户直接通过浏览器登录 http://192.168.0.xxx:8082 ，通过账号密码登录，便可以配置和构建项目。\n\n### jenkins相对Mac OS Server的优点:\n\n1. 同一局域网便可以登录，登录之后便可以自行配置项目\n2. 似乎可以并行构建任务\n\n当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png)\n而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png)\n这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。\n\n但是jenkins有更方便的打包方式:\njenkins开启token，不需要用户名登录便可以打包:\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png)\n\n这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。\n系统管理->全局安全配置->勾选 Allow anonymous read access\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png)\n\n接着，我们便可以通过命令来打包:\n```\ncurl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&cause\\=testBuild\n```\n\n| 参数       \t\t\t\t\t\t| 注释    |\n| --------   \t\t\t\t\t\t| -----:   |\n| notification_extension_test | 项目名称     |\n| token       \t\t\t\t\t| 上面设置的token    |\n| cause        \t\t\t\t\t| 可选参数，可不传      |\n\n这样似乎可以用一台服务器，将打包任务部署到指定机器上:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png)\n这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。\n\n## 关于Server和jenkins的一些总结:\n1. 如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；\n2. 对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；\n3. 如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。\n\n## fastlane及打包脚本简单介绍\n说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:\n\n1. 避免繁琐的路径拼接，拷贝等\n2. 修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败\n\n我们来简单看一段fastlane的打包代码:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png)\n\n上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行\n\n```\nfastlane adhocMyApp version:100000  // 100000是传的版本号\n```\n便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png)\n\n发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png)\n\n我们再看终端，看看fastlane究竟做了些啥\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png)\n\n也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:\n\n```\n// 对应手动打包archive\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationRelease} -archivePath ${archivePath}\n// 对应导出步骤\nxcodebuild -exportArchive -archivePath ${archivePath} -exportPath ${exportPath} -exportOptionsPlist ${exportOptionsPlist}\n\n```\n\n上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。\n\n经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。\n\n## 总结\n本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。\n","source":"_posts/关于iOS自动化打包的一些分享.md","raw":"---\ntitle: 关于iOS自动化打包的一些分享\ndate: 2018-01-11\ncategories: \n---\n\n说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。\n\n即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。\n\n本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。\n\n谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。\n\n## Server相比于jenkins，我总结优点有三: \n\n1. 相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；\n2. 直接使用xcode就可开始构建项目，而不需要登录网页；\n3. 集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。\n \n这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。\n\n下面我介绍使用过程中需要注意的一些方面: \n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png)\n\n如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。\n\n如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。\n\n上面所说的plist文件大体结构是这样的:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png)\n\n这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。\n\n在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，\nhttps://192.168.0.xxx/xcode/lastest 或 https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png)\n\n\n## 关于jenkins的一些配置注意事项:\n### 以下是我在配置过程中踩到的一些坑:\n\n1. 8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；\n2. git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png)\n\n接下来，其他用户直接通过浏览器登录 http://192.168.0.xxx:8082 ，通过账号密码登录，便可以配置和构建项目。\n\n### jenkins相对Mac OS Server的优点:\n\n1. 同一局域网便可以登录，登录之后便可以自行配置项目\n2. 似乎可以并行构建任务\n\n当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png)\n而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png)\n这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。\n\n但是jenkins有更方便的打包方式:\njenkins开启token，不需要用户名登录便可以打包:\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png)\n\n这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。\n系统管理->全局安全配置->勾选 Allow anonymous read access\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png)\n\n接着，我们便可以通过命令来打包:\n```\ncurl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&cause\\=testBuild\n```\n\n| 参数       \t\t\t\t\t\t| 注释    |\n| --------   \t\t\t\t\t\t| -----:   |\n| notification_extension_test | 项目名称     |\n| token       \t\t\t\t\t| 上面设置的token    |\n| cause        \t\t\t\t\t| 可选参数，可不传      |\n\n这样似乎可以用一台服务器，将打包任务部署到指定机器上:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png)\n这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。\n\n## 关于Server和jenkins的一些总结:\n1. 如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；\n2. 对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；\n3. 如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。\n\n## fastlane及打包脚本简单介绍\n说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:\n\n1. 避免繁琐的路径拼接，拷贝等\n2. 修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败\n\n我们来简单看一段fastlane的打包代码:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png)\n\n上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行\n\n```\nfastlane adhocMyApp version:100000  // 100000是传的版本号\n```\n便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png)\n\n发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png)\n\n我们再看终端，看看fastlane究竟做了些啥\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png)\n\n也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:\n\n```\n// 对应手动打包archive\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationRelease} -archivePath ${archivePath}\n// 对应导出步骤\nxcodebuild -exportArchive -archivePath ${archivePath} -exportPath ${exportPath} -exportOptionsPlist ${exportOptionsPlist}\n\n```\n\n上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。\n\n经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。\n\n## 总结\n本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。\n","slug":"关于iOS自动化打包的一些分享","published":1,"updated":"2018-06-28T02:20:20.105Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj0yvtu10001gozy7em6b3v2","content":"<p>说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。</p>\n<p>即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。</p>\n<p>本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。</p>\n<p>谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。</p>\n<h2 id=\"Server相比于jenkins，我总结优点有三\"><a href=\"#Server相比于jenkins，我总结优点有三\" class=\"headerlink\" title=\"Server相比于jenkins，我总结优点有三:\"></a>Server相比于jenkins，我总结优点有三:</h2><ol>\n<li>相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；</li>\n<li>直接使用xcode就可开始构建项目，而不需要登录网页；</li>\n<li>集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。</li>\n</ol>\n<p>这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。</p>\n<p>下面我介绍使用过程中需要注意的一些方面: </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png\" alt=\"\"></p>\n<p>如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。</p>\n<p>如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。</p>\n<p>上面所说的plist文件大体结构是这样的:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png\" alt=\"\"></p>\n<p>这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。</p>\n<p>在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，<br><a href=\"https://192.168.0.xxx/xcode/lastest\" target=\"_blank\" rel=\"noopener\">https://192.168.0.xxx/xcode/lastest</a> 或 <a href=\"https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\" target=\"_blank\" rel=\"noopener\">https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。</a><br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png\" alt=\"\"></p>\n<h2 id=\"关于jenkins的一些配置注意事项\"><a href=\"#关于jenkins的一些配置注意事项\" class=\"headerlink\" title=\"关于jenkins的一些配置注意事项:\"></a>关于jenkins的一些配置注意事项:</h2><h3 id=\"以下是我在配置过程中踩到的一些坑\"><a href=\"#以下是我在配置过程中踩到的一些坑\" class=\"headerlink\" title=\"以下是我在配置过程中踩到的一些坑:\"></a>以下是我在配置过程中踩到的一些坑:</h3><ol>\n<li>8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；</li>\n<li>git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；</li>\n</ol>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png\" alt=\"\"></p>\n<p>接下来，其他用户直接通过浏览器登录 <a href=\"http://192.168.0.xxx:8082\" target=\"_blank\" rel=\"noopener\">http://192.168.0.xxx:8082</a> ，通过账号密码登录，便可以配置和构建项目。</p>\n<h3 id=\"jenkins相对Mac-OS-Server的优点\"><a href=\"#jenkins相对Mac-OS-Server的优点\" class=\"headerlink\" title=\"jenkins相对Mac OS Server的优点:\"></a>jenkins相对Mac OS Server的优点:</h3><ol>\n<li>同一局域网便可以登录，登录之后便可以自行配置项目</li>\n<li>似乎可以并行构建任务</li>\n</ol>\n<p>当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png\" alt=\"\"><br>而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png\" alt=\"\"><br>这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。</p>\n<p>但是jenkins有更方便的打包方式:<br>jenkins开启token，不需要用户名登录便可以打包:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png\" alt=\"\"></p>\n<p>这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。<br>系统管理-&gt;全局安全配置-&gt;勾选 Allow anonymous read access<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png\" alt=\"\"></p>\n<p>接着，我们便可以通过命令来打包:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&amp;cause\\=testBuild</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>notification_extension_test</td>\n<td style=\"text-align:right\">项目名称</td>\n</tr>\n<tr>\n<td>token</td>\n<td style=\"text-align:right\">上面设置的token</td>\n</tr>\n<tr>\n<td>cause</td>\n<td style=\"text-align:right\">可选参数，可不传</td>\n</tr>\n</tbody>\n</table>\n<p>这样似乎可以用一台服务器，将打包任务部署到指定机器上:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png\" alt=\"\"><br>这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。</p>\n<h2 id=\"关于Server和jenkins的一些总结\"><a href=\"#关于Server和jenkins的一些总结\" class=\"headerlink\" title=\"关于Server和jenkins的一些总结:\"></a>关于Server和jenkins的一些总结:</h2><ol>\n<li>如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；</li>\n<li>对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；</li>\n<li>如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。</li>\n</ol>\n<h2 id=\"fastlane及打包脚本简单介绍\"><a href=\"#fastlane及打包脚本简单介绍\" class=\"headerlink\" title=\"fastlane及打包脚本简单介绍\"></a>fastlane及打包脚本简单介绍</h2><p>说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:</p>\n<ol>\n<li>避免繁琐的路径拼接，拷贝等</li>\n<li>修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败</li>\n</ol>\n<p>我们来简单看一段fastlane的打包代码:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png\" alt=\"\"></p>\n<p>上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane adhocMyApp version:100000  // 100000是传的版本号</span><br></pre></td></tr></table></figure>\n<p>便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png\" alt=\"\"></p>\n<p>发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png\" alt=\"\"></p>\n<p>我们再看终端，看看fastlane究竟做了些啥<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png\" alt=\"\"></p>\n<p>也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对应手动打包archive</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationRelease&#125; -archivePath $&#123;archivePath&#125;</span><br><span class=\"line\">// 对应导出步骤</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archivePath&#125; -exportPath $&#123;exportPath&#125; -exportOptionsPlist $&#123;exportOptionsPlist&#125;</span><br></pre></td></tr></table></figure>\n<p>上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。</p>\n<p>经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。</p>\n<p>即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。</p>\n<p>本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。</p>\n<p>谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。</p>\n<h2 id=\"Server相比于jenkins，我总结优点有三\"><a href=\"#Server相比于jenkins，我总结优点有三\" class=\"headerlink\" title=\"Server相比于jenkins，我总结优点有三:\"></a>Server相比于jenkins，我总结优点有三:</h2><ol>\n<li>相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；</li>\n<li>直接使用xcode就可开始构建项目，而不需要登录网页；</li>\n<li>集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。</li>\n</ol>\n<p>这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。</p>\n<p>下面我介绍使用过程中需要注意的一些方面: </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png\" alt=\"\"></p>\n<p>如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。</p>\n<p>如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。</p>\n<p>上面所说的plist文件大体结构是这样的:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png\" alt=\"\"></p>\n<p>这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。</p>\n<p>在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，<br><a href=\"https://192.168.0.xxx/xcode/lastest\" target=\"_blank\" rel=\"noopener\">https://192.168.0.xxx/xcode/lastest</a> 或 <a href=\"https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\" target=\"_blank\" rel=\"noopener\">https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。</a><br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png\" alt=\"\"></p>\n<h2 id=\"关于jenkins的一些配置注意事项\"><a href=\"#关于jenkins的一些配置注意事项\" class=\"headerlink\" title=\"关于jenkins的一些配置注意事项:\"></a>关于jenkins的一些配置注意事项:</h2><h3 id=\"以下是我在配置过程中踩到的一些坑\"><a href=\"#以下是我在配置过程中踩到的一些坑\" class=\"headerlink\" title=\"以下是我在配置过程中踩到的一些坑:\"></a>以下是我在配置过程中踩到的一些坑:</h3><ol>\n<li>8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；</li>\n<li>git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；</li>\n</ol>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png\" alt=\"\"></p>\n<p>接下来，其他用户直接通过浏览器登录 <a href=\"http://192.168.0.xxx:8082\" target=\"_blank\" rel=\"noopener\">http://192.168.0.xxx:8082</a> ，通过账号密码登录，便可以配置和构建项目。</p>\n<h3 id=\"jenkins相对Mac-OS-Server的优点\"><a href=\"#jenkins相对Mac-OS-Server的优点\" class=\"headerlink\" title=\"jenkins相对Mac OS Server的优点:\"></a>jenkins相对Mac OS Server的优点:</h3><ol>\n<li>同一局域网便可以登录，登录之后便可以自行配置项目</li>\n<li>似乎可以并行构建任务</li>\n</ol>\n<p>当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png\" alt=\"\"><br>而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png\" alt=\"\"><br>这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。</p>\n<p>但是jenkins有更方便的打包方式:<br>jenkins开启token，不需要用户名登录便可以打包:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png\" alt=\"\"></p>\n<p>这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。<br>系统管理-&gt;全局安全配置-&gt;勾选 Allow anonymous read access<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png\" alt=\"\"></p>\n<p>接着，我们便可以通过命令来打包:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&amp;cause\\=testBuild</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>notification_extension_test</td>\n<td style=\"text-align:right\">项目名称</td>\n</tr>\n<tr>\n<td>token</td>\n<td style=\"text-align:right\">上面设置的token</td>\n</tr>\n<tr>\n<td>cause</td>\n<td style=\"text-align:right\">可选参数，可不传</td>\n</tr>\n</tbody>\n</table>\n<p>这样似乎可以用一台服务器，将打包任务部署到指定机器上:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png\" alt=\"\"><br>这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。</p>\n<h2 id=\"关于Server和jenkins的一些总结\"><a href=\"#关于Server和jenkins的一些总结\" class=\"headerlink\" title=\"关于Server和jenkins的一些总结:\"></a>关于Server和jenkins的一些总结:</h2><ol>\n<li>如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；</li>\n<li>对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；</li>\n<li>如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。</li>\n</ol>\n<h2 id=\"fastlane及打包脚本简单介绍\"><a href=\"#fastlane及打包脚本简单介绍\" class=\"headerlink\" title=\"fastlane及打包脚本简单介绍\"></a>fastlane及打包脚本简单介绍</h2><p>说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:</p>\n<ol>\n<li>避免繁琐的路径拼接，拷贝等</li>\n<li>修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败</li>\n</ol>\n<p>我们来简单看一段fastlane的打包代码:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png\" alt=\"\"></p>\n<p>上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane adhocMyApp version:100000  // 100000是传的版本号</span><br></pre></td></tr></table></figure>\n<p>便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png\" alt=\"\"></p>\n<p>发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png\" alt=\"\"></p>\n<p>我们再看终端，看看fastlane究竟做了些啥<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png\" alt=\"\"></p>\n<p>也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对应手动打包archive</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationRelease&#125; -archivePath $&#123;archivePath&#125;</span><br><span class=\"line\">// 对应导出步骤</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archivePath&#125; -exportPath $&#123;exportPath&#125; -exportOptionsPlist $&#123;exportOptionsPlist&#125;</span><br></pre></td></tr></table></figure>\n<p>上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。</p>\n<p>经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。</p>\n"},{"title":"通过Method运行时内存布局hook方法探索","date":"2018-06-29T16:00:00.000Z","_content":"\n在iOS开发中, Method Swizzling想必大家都不陌生, 可以以此来对方法进行hook, 做一些我们希望做的事情, 比如页面进入退出, 可以对viewWillAppear及viewWillDisappear进行hook, 从而进行一些埋点日志相关的事情。\n\n那么, Method Swizzling的原理到底是怎样的呢? 这个问题, 即使没自己研究过, 大多数人也有所耳闻, 简单来说, 无非就是修改方法的imp指向, 让其指向我们hook的方法。如果是这样的话, 我们是否可以不用Runtime提供的API如method_setImplementation、method_exchangeImplementation等函数而通过对象及方法的内存布局来实现呢? 答案是肯定的, 下面便是我在此过程中的一些探索和理解。\n\n本文描述大部分内容对开发没有太大帮助, 但是对于更加了解运行时方法调用有一定帮助。\n\n# 直接赋值Method的IMP进行hook\n\n要想通过方法的内存布局来修改, 一定要对方法的内存布局有所了解, 查看源码可以知道Method的内存布局如下所示:\n\n```\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function<const method_t&,\n                                    const method_t&, bool>\n    {\n        bool operator() (const method_t& lhs,\n                         const method_t& rhs)\n        { return lhs.name < rhs.name; }\n    };\n};\n```\n\n上面结构中, 很容易就找到我们想要的东西IMP, 话不多少, 赶紧进行hook。\n\n```\n@implementation Person\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n        \n        SEL originalSelector = @selector(sayHello);\n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n       \n        struct method_t *method = (struct method_t *)originalMethod;\n        method->imp = (IMP)hookedSayHello;\n    });\n}\n\n- (void)sayHello {\n    NSLog(@\"Hello, everybody!\");\n}\n\nvoid hookedSayHello (id self, SEL _cmd, ...) {\n    NSLog(@\"This is hooked sayHello\");\n}\n\n@end\n```\n\n然后再main.m中调用:\n\n```\n    Person *person = [[Person alloc] init];\n    [person sayHello];\n```\n\n### 遇到的问题, 还是调用原来的方法实现\n\n此时却发现, 打印出来的却和我想象不太一样, 仍然是调用了原来的sayHello方法, 而且打个断点发现method的imp指针也确实指向了 void hookedSayHello (id self, SEL _cmd, ...) 这个函数,  这确实有些让人捉摸不透。 \n\n![直接修改方法imp](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/hooked_imp.png)\n\n### 浅尝辄止--method _setImplementation\n\n于是怀疑人生的我, 又使用Runtime提供的API method_setImplementation进行相同操作, 发现和以往一样, 毫无问题, 那么一定是做了一些处理, 查其源码, 发现了一个很可疑的函数 flushCaches, 见名知意, 清除缓存。\n\n```\nstatic IMP \n_method_setImplementation(Class cls, method_t *m, IMP imp)\n{\n    runtimeLock.assertWriting();\n\n    if (!m) return nil;\n    if (!imp) return nil;\n\n    IMP old = m->imp;\n    m->imp = imp;\n\n    // Cache updates are slow if cls is nil (i.e. unknown)\n    // RR/AWZ updates are slow if cls is nil (i.e. unknown)\n    // fixme build list of classes whose Methods are known externally?\n\n    flushCaches(cls); \n\n    updateCustomRR_AWZ(cls, m);\n\n    return old;\n}\n\n\n/***********************************************************************\n* _objc_flush_caches\n* Flushes all caches.\n* (Historical behavior: flush caches for cls, its metaclass, \n* and subclasses thereof. Nil flushes all classes.)\n* Locking: acquires runtimeLock\n**********************************************************************/\nstatic void flushCaches(Class cls)\n{\n    runtimeLock.assertWriting();\n\n    mutex_locker_t lock(cacheUpdateLock);\n\n    if (cls) {\n        foreach_realized_class_and_subclass(cls, ^(Class c){ // 遍历子类\n            cache_erase_nolock(c);\n        });\n    }\n    else {\n        foreach_realized_class_and_metaclass(^(Class c){\n            cache_erase_nolock(c);\n        });\n    }\n}\n\n// Reset this entire cache to the uncached lookup by reallocating it.\n// This must not shrink the cache - that breaks the lock-free scheme.\nvoid cache_erase_nolock(Class cls)\n{\n    cacheUpdateLock.assertLocked();\n\n    cache_t *cache = getCache(cls);\n\n    mask_t capacity = cache->capacity();\n    if (capacity > 0  &&  cache->occupied() > 0) {\n        auto oldBuckets = cache->buckets();\n        auto buckets = emptyBucketsForCapacity(capacity);\n        cache->setBucketsAndMask(buckets, capacity - 1); // also clears occupied\n\n        cache_collect_free(oldBuckets, capacity);\n        cache_collect(false);\n    }\n}\n\n```\n\n如上述源码可知, 在flushCaches函数中, 这个函数会把当前类本身, 当前类的元类以及当前类的子类的方法缓存全部清空, 这里我们也可以自己验证一下, \n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n        \n        SEL originalSelector = @selector(sayHello);\n              \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n        \n        \n//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果\n        \n        struct method_t *method = (struct method_t *)originalMethod;\n//        method->imp = (IMP)hookedSayHello; // 直接复制imp指针\n\n        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;\n        uint32_t cacheCount = clz->cache.capacity();\n        NSLog(@\"cacheCount : %d\", cacheCount);\n        \n        \n        for (NSInteger i = 0; i < cacheCount; i++) {\n            char *key = (char *)((clz->cache._buckets + i)->_key);\n            // 这里设置一下\n            printf(\"%ld - %s\\n\", i, key); // 测试\n    });\n}\n\n```\n\n当调用Runtime API method_setImplementation, 打印如下图所示:\n![调用Runtime API method_setImplementation,cache被清除](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/method_setImplementation_cache.png)\n当直接给imp指针赋值, 打印如下图所示:\n![imp指针赋值,cache没被清除](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache.png)\n\n可以看出, 当直接给imp指针复制, 不清除方法缓存, 其中打印的sayHello正是我们hook的方法, 之前的疑惑也一扫而空, 虽然方法的imp指向发生了改变, 但是方法缓存中的sayHello对应的imp并没有发生改变。\n\n我们知道, Objective-C通过方法缓存来提升方法调用速度, 缓存中找不到, 再去类对象的方法列表中去查找, 调用后便加入到方法缓存中, 这点也可以通过objc_msgSend的源码来确认, objc_msgSend的源码是汇编实现的, 即使看不懂汇编也没事, 通过旁边的注释, 大概来看出来调用流程: 在方法缓存中寻找, 找到直接返回方法IMP, 否则调用__objc_msgSend_uncached, 去方法列表中查找。\n\n\n```\n/// objc_msgSend, 除去一些nil验证检测后, 调用 CacheLookup LOOKUP\nLLookup_GetIsaDone:\n\tCacheLookup LOOKUP\t\t// returns imp\n\n\n/// CacheLookup\n\t.macro CacheHit\n.if $0 == NORMAL\n\tMESSENGER_END_FAST\n\tbr\tx17\t\t\t// call imp\n.elseif $0 == GETIMP\n\tmov\tx0, x17\t\t\t// return imp\n\tret\n.elseif $0 == LOOKUP\n\tret\t\t\t\t// return imp via x17\n.else\n.abort oops\n.endif\n.endmacro\n\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tx9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tx9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tx9, __objc_msgLookup_uncached\n\n```\n\n# 作怪到底--自己修改方法缓存对应的imp\n\n既然都到这里, 不妨尝试自己去修改方法缓存中对应imp。其实从Objective-C Runtime层面来说, 对象、方法、block等都是以结构体的形式存在内存中, 想去改对象的属性, 方法的实现会是block的实现, 都是要对它们的内存布局有所了解。\n\n前面的分析把疑惑基本解决了, 现在要做的就比较简单是了, 只需要将方法缓存以及其他需要用到的结构体如对象、方法等的结构抽出来, 自己声明一个结构体, 把需要用上的成员变量和方法带上即可, 不需要用上可以直接删除。\n\n```\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\npublic:\n    struct bucket_t *buckets();\n    mask_t mask();\n    mask_t occupied();\n    void incrementOccupied();\n    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);\n    void initializeToEmpty();\n    \n    mask_t capacity();\n    bool isConstantEmptyCache();\n    bool canBeFreed();\n    \n    static size_t bytesForCapacity(uint32_t cap);\n    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);\n    \n    void expand();\n    void reallocate(mask_t oldCapacity, mask_t newCapacity);\n    struct bucket_t * find(cache_key_t key, id receiver);\n    \n    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));\n};\n\n```\n\n接下来, 只需要将load方法中添加一点代码进行验证即可:\n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n//        Class aClass = self; // 不给self发消息, cache不会生成, 结果就和我们的预想一样\n        \n        SEL originalSelector = @selector(sayHello);\n        \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n        \n//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果\n        \n        struct method_t *method = (struct method_t *)originalMethod;\n        method->imp = (IMP)hookedSayHello;\n        \n        // cache问题, 因为 已经和 imp缓存了, 直接会调用原来方法\n        // method_setImplementation 中有个函数 flushCache -> cache_erase_nolock, 会重新设置 cache\n        \n        // 修改cache\n        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;\n        uint32_t cacheCount = clz->cache.capacity();\n        NSLog(@\"cacheCount : %d\", cacheCount);\n        \n        \n        for (NSInteger i = 0; i < cacheCount; i++) {\n            char *key = (char *)((clz->cache._buckets + i)->_key);\n            // 这里设置一下\n            printf(\"%ld - %s\\n\", i, key); // 测试\n            \n            if (key) {\n                NSString *selectorName = [NSString stringWithUTF8String:key];\n\n                if ([selectorName isEqualToString:@\"sayHello\"]) {\n                    (clz->cache._buckets + i)->_imp = (IMP)hookedSayHello;\n                }\n            }\n        }\n    });\n}\n\n```\n![自己修改cache](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache_and_change_cache_imp.png)\n\n发现打印的确实是我们希望的实现, 当然这里只是一个简单的类, 对于有子类的情况没做验证, 如果有子类的情况下, 还是比较复杂的, 对于子类是否实现了该方法也是有区别的, 这也许也是 method_setImplementation 直接暴力地将当前类和子类的缓存都清空的原因吧!\n\n\n# 总结\n\n通过本次探索, 对方法调用以及底层的一些流程有了一定的了解, 虽然对于开发确实没太大帮助, 但对于理解底层机制有一定帮助。在日常学习中, 可以配合源码, 通过自己的尝试, 一定可以对相关知识有更深刻地理解。\n\n代码地址: [https://github.com/LoyalToOrigin/HookMethodWithLayout]()\n\n\n\n\n\n","source":"_posts/通过Method运行时内存布局hook方法探索.md","raw":"---\ntitle: 通过Method运行时内存布局hook方法探索\ndate: 2018-06-30\ncategories: \n---\n\n在iOS开发中, Method Swizzling想必大家都不陌生, 可以以此来对方法进行hook, 做一些我们希望做的事情, 比如页面进入退出, 可以对viewWillAppear及viewWillDisappear进行hook, 从而进行一些埋点日志相关的事情。\n\n那么, Method Swizzling的原理到底是怎样的呢? 这个问题, 即使没自己研究过, 大多数人也有所耳闻, 简单来说, 无非就是修改方法的imp指向, 让其指向我们hook的方法。如果是这样的话, 我们是否可以不用Runtime提供的API如method_setImplementation、method_exchangeImplementation等函数而通过对象及方法的内存布局来实现呢? 答案是肯定的, 下面便是我在此过程中的一些探索和理解。\n\n本文描述大部分内容对开发没有太大帮助, 但是对于更加了解运行时方法调用有一定帮助。\n\n# 直接赋值Method的IMP进行hook\n\n要想通过方法的内存布局来修改, 一定要对方法的内存布局有所了解, 查看源码可以知道Method的内存布局如下所示:\n\n```\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n\n    struct SortBySELAddress :\n        public std::binary_function<const method_t&,\n                                    const method_t&, bool>\n    {\n        bool operator() (const method_t& lhs,\n                         const method_t& rhs)\n        { return lhs.name < rhs.name; }\n    };\n};\n```\n\n上面结构中, 很容易就找到我们想要的东西IMP, 话不多少, 赶紧进行hook。\n\n```\n@implementation Person\n\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n        \n        SEL originalSelector = @selector(sayHello);\n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n       \n        struct method_t *method = (struct method_t *)originalMethod;\n        method->imp = (IMP)hookedSayHello;\n    });\n}\n\n- (void)sayHello {\n    NSLog(@\"Hello, everybody!\");\n}\n\nvoid hookedSayHello (id self, SEL _cmd, ...) {\n    NSLog(@\"This is hooked sayHello\");\n}\n\n@end\n```\n\n然后再main.m中调用:\n\n```\n    Person *person = [[Person alloc] init];\n    [person sayHello];\n```\n\n### 遇到的问题, 还是调用原来的方法实现\n\n此时却发现, 打印出来的却和我想象不太一样, 仍然是调用了原来的sayHello方法, 而且打个断点发现method的imp指针也确实指向了 void hookedSayHello (id self, SEL _cmd, ...) 这个函数,  这确实有些让人捉摸不透。 \n\n![直接修改方法imp](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/hooked_imp.png)\n\n### 浅尝辄止--method _setImplementation\n\n于是怀疑人生的我, 又使用Runtime提供的API method_setImplementation进行相同操作, 发现和以往一样, 毫无问题, 那么一定是做了一些处理, 查其源码, 发现了一个很可疑的函数 flushCaches, 见名知意, 清除缓存。\n\n```\nstatic IMP \n_method_setImplementation(Class cls, method_t *m, IMP imp)\n{\n    runtimeLock.assertWriting();\n\n    if (!m) return nil;\n    if (!imp) return nil;\n\n    IMP old = m->imp;\n    m->imp = imp;\n\n    // Cache updates are slow if cls is nil (i.e. unknown)\n    // RR/AWZ updates are slow if cls is nil (i.e. unknown)\n    // fixme build list of classes whose Methods are known externally?\n\n    flushCaches(cls); \n\n    updateCustomRR_AWZ(cls, m);\n\n    return old;\n}\n\n\n/***********************************************************************\n* _objc_flush_caches\n* Flushes all caches.\n* (Historical behavior: flush caches for cls, its metaclass, \n* and subclasses thereof. Nil flushes all classes.)\n* Locking: acquires runtimeLock\n**********************************************************************/\nstatic void flushCaches(Class cls)\n{\n    runtimeLock.assertWriting();\n\n    mutex_locker_t lock(cacheUpdateLock);\n\n    if (cls) {\n        foreach_realized_class_and_subclass(cls, ^(Class c){ // 遍历子类\n            cache_erase_nolock(c);\n        });\n    }\n    else {\n        foreach_realized_class_and_metaclass(^(Class c){\n            cache_erase_nolock(c);\n        });\n    }\n}\n\n// Reset this entire cache to the uncached lookup by reallocating it.\n// This must not shrink the cache - that breaks the lock-free scheme.\nvoid cache_erase_nolock(Class cls)\n{\n    cacheUpdateLock.assertLocked();\n\n    cache_t *cache = getCache(cls);\n\n    mask_t capacity = cache->capacity();\n    if (capacity > 0  &&  cache->occupied() > 0) {\n        auto oldBuckets = cache->buckets();\n        auto buckets = emptyBucketsForCapacity(capacity);\n        cache->setBucketsAndMask(buckets, capacity - 1); // also clears occupied\n\n        cache_collect_free(oldBuckets, capacity);\n        cache_collect(false);\n    }\n}\n\n```\n\n如上述源码可知, 在flushCaches函数中, 这个函数会把当前类本身, 当前类的元类以及当前类的子类的方法缓存全部清空, 这里我们也可以自己验证一下, \n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n        \n        SEL originalSelector = @selector(sayHello);\n              \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n        \n        \n//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果\n        \n        struct method_t *method = (struct method_t *)originalMethod;\n//        method->imp = (IMP)hookedSayHello; // 直接复制imp指针\n\n        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;\n        uint32_t cacheCount = clz->cache.capacity();\n        NSLog(@\"cacheCount : %d\", cacheCount);\n        \n        \n        for (NSInteger i = 0; i < cacheCount; i++) {\n            char *key = (char *)((clz->cache._buckets + i)->_key);\n            // 这里设置一下\n            printf(\"%ld - %s\\n\", i, key); // 测试\n    });\n}\n\n```\n\n当调用Runtime API method_setImplementation, 打印如下图所示:\n![调用Runtime API method_setImplementation,cache被清除](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/method_setImplementation_cache.png)\n当直接给imp指针赋值, 打印如下图所示:\n![imp指针赋值,cache没被清除](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache.png)\n\n可以看出, 当直接给imp指针复制, 不清除方法缓存, 其中打印的sayHello正是我们hook的方法, 之前的疑惑也一扫而空, 虽然方法的imp指向发生了改变, 但是方法缓存中的sayHello对应的imp并没有发生改变。\n\n我们知道, Objective-C通过方法缓存来提升方法调用速度, 缓存中找不到, 再去类对象的方法列表中去查找, 调用后便加入到方法缓存中, 这点也可以通过objc_msgSend的源码来确认, objc_msgSend的源码是汇编实现的, 即使看不懂汇编也没事, 通过旁边的注释, 大概来看出来调用流程: 在方法缓存中寻找, 找到直接返回方法IMP, 否则调用__objc_msgSend_uncached, 去方法列表中查找。\n\n\n```\n/// objc_msgSend, 除去一些nil验证检测后, 调用 CacheLookup LOOKUP\nLLookup_GetIsaDone:\n\tCacheLookup LOOKUP\t\t// returns imp\n\n\n/// CacheLookup\n\t.macro CacheHit\n.if $0 == NORMAL\n\tMESSENGER_END_FAST\n\tbr\tx17\t\t\t// call imp\n.elseif $0 == GETIMP\n\tmov\tx0, x17\t\t\t// return imp\n\tret\n.elseif $0 == LOOKUP\n\tret\t\t\t\t// return imp via x17\n.else\n.abort oops\n.endif\n.endmacro\n\n.macro CheckMiss\n\t// miss if bucket->sel == 0\n.if $0 == GETIMP\n\tcbz\tx9, LGetImpMiss\n.elseif $0 == NORMAL\n\tcbz\tx9, __objc_msgSend_uncached\n.elseif $0 == LOOKUP\n\tcbz\tx9, __objc_msgLookup_uncached\n\n```\n\n# 作怪到底--自己修改方法缓存对应的imp\n\n既然都到这里, 不妨尝试自己去修改方法缓存中对应imp。其实从Objective-C Runtime层面来说, 对象、方法、block等都是以结构体的形式存在内存中, 想去改对象的属性, 方法的实现会是block的实现, 都是要对它们的内存布局有所了解。\n\n前面的分析把疑惑基本解决了, 现在要做的就比较简单是了, 只需要将方法缓存以及其他需要用到的结构体如对象、方法等的结构抽出来, 自己声明一个结构体, 把需要用上的成员变量和方法带上即可, 不需要用上可以直接删除。\n\n```\nstruct bucket_t {\n    cache_key_t _key;\n    IMP _imp;\n};\n\nstruct cache_t {\n    bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\npublic:\n    struct bucket_t *buckets();\n    mask_t mask();\n    mask_t occupied();\n    void incrementOccupied();\n    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);\n    void initializeToEmpty();\n    \n    mask_t capacity();\n    bool isConstantEmptyCache();\n    bool canBeFreed();\n    \n    static size_t bytesForCapacity(uint32_t cap);\n    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);\n    \n    void expand();\n    void reallocate(mask_t oldCapacity, mask_t newCapacity);\n    struct bucket_t * find(cache_key_t key, id receiver);\n    \n    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));\n};\n\n```\n\n接下来, 只需要将load方法中添加一点代码进行验证即可:\n\n```\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        Class aClass = [self class];\n//        Class aClass = self; // 不给self发消息, cache不会生成, 结果就和我们的预想一样\n        \n        SEL originalSelector = @selector(sayHello);\n        \n        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);\n        \n//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果\n        \n        struct method_t *method = (struct method_t *)originalMethod;\n        method->imp = (IMP)hookedSayHello;\n        \n        // cache问题, 因为 已经和 imp缓存了, 直接会调用原来方法\n        // method_setImplementation 中有个函数 flushCache -> cache_erase_nolock, 会重新设置 cache\n        \n        // 修改cache\n        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;\n        uint32_t cacheCount = clz->cache.capacity();\n        NSLog(@\"cacheCount : %d\", cacheCount);\n        \n        \n        for (NSInteger i = 0; i < cacheCount; i++) {\n            char *key = (char *)((clz->cache._buckets + i)->_key);\n            // 这里设置一下\n            printf(\"%ld - %s\\n\", i, key); // 测试\n            \n            if (key) {\n                NSString *selectorName = [NSString stringWithUTF8String:key];\n\n                if ([selectorName isEqualToString:@\"sayHello\"]) {\n                    (clz->cache._buckets + i)->_imp = (IMP)hookedSayHello;\n                }\n            }\n        }\n    });\n}\n\n```\n![自己修改cache](http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache_and_change_cache_imp.png)\n\n发现打印的确实是我们希望的实现, 当然这里只是一个简单的类, 对于有子类的情况没做验证, 如果有子类的情况下, 还是比较复杂的, 对于子类是否实现了该方法也是有区别的, 这也许也是 method_setImplementation 直接暴力地将当前类和子类的缓存都清空的原因吧!\n\n\n# 总结\n\n通过本次探索, 对方法调用以及底层的一些流程有了一定的了解, 虽然对于开发确实没太大帮助, 但对于理解底层机制有一定帮助。在日常学习中, 可以配合源码, 通过自己的尝试, 一定可以对相关知识有更深刻地理解。\n\n代码地址: [https://github.com/LoyalToOrigin/HookMethodWithLayout]()\n\n\n\n\n\n","slug":"通过Method运行时内存布局hook方法探索","published":1,"updated":"2018-06-30T05:21:32.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjj0yvtu60002gozyrbb2ugun","content":"<p>在iOS开发中, Method Swizzling想必大家都不陌生, 可以以此来对方法进行hook, 做一些我们希望做的事情, 比如页面进入退出, 可以对viewWillAppear及viewWillDisappear进行hook, 从而进行一些埋点日志相关的事情。</p>\n<p>那么, Method Swizzling的原理到底是怎样的呢? 这个问题, 即使没自己研究过, 大多数人也有所耳闻, 简单来说, 无非就是修改方法的imp指向, 让其指向我们hook的方法。如果是这样的话, 我们是否可以不用Runtime提供的API如method_setImplementation、method_exchangeImplementation等函数而通过对象及方法的内存布局来实现呢? 答案是肯定的, 下面便是我在此过程中的一些探索和理解。</p>\n<p>本文描述大部分内容对开发没有太大帮助, 但是对于更加了解运行时方法调用有一定帮助。</p>\n<h1 id=\"直接赋值Method的IMP进行hook\"><a href=\"#直接赋值Method的IMP进行hook\" class=\"headerlink\" title=\"直接赋值Method的IMP进行hook\"></a>直接赋值Method的IMP进行hook</h1><p>要想通过方法的内存布局来修改, 一定要对方法的内存布局有所了解, 查看源码可以知道Method的内存布局如下所示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct method_t &#123;</span><br><span class=\"line\">    SEL name;</span><br><span class=\"line\">    const char *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct SortBySELAddress :</span><br><span class=\"line\">        public std::binary_function&lt;const method_t&amp;,</span><br><span class=\"line\">                                    const method_t&amp;, bool&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bool operator() (const method_t&amp; lhs,</span><br><span class=\"line\">                         const method_t&amp; rhs)</span><br><span class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面结构中, 很容易就找到我们想要的东西IMP, 话不多少, 赶紧进行hook。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">       </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">        method-&gt;imp = (IMP)hookedSayHello;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)sayHello &#123;</span><br><span class=\"line\">    NSLog(@&quot;Hello, everybody!&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void hookedSayHello (id self, SEL _cmd, ...) &#123;</span><br><span class=\"line\">    NSLog(@&quot;This is hooked sayHello&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>然后再main.m中调用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [[Person alloc] init];</span><br><span class=\"line\">[person sayHello];</span><br></pre></td></tr></table></figure>\n<h3 id=\"遇到的问题-还是调用原来的方法实现\"><a href=\"#遇到的问题-还是调用原来的方法实现\" class=\"headerlink\" title=\"遇到的问题, 还是调用原来的方法实现\"></a>遇到的问题, 还是调用原来的方法实现</h3><p>此时却发现, 打印出来的却和我想象不太一样, 仍然是调用了原来的sayHello方法, 而且打个断点发现method的imp指针也确实指向了 void hookedSayHello (id self, SEL _cmd, …) 这个函数,  这确实有些让人捉摸不透。 </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/hooked_imp.png\" alt=\"直接修改方法imp\"></p>\n<h3 id=\"浅尝辄止–method-setImplementation\"><a href=\"#浅尝辄止–method-setImplementation\" class=\"headerlink\" title=\"浅尝辄止–method _setImplementation\"></a>浅尝辄止–method _setImplementation</h3><p>于是怀疑人生的我, 又使用Runtime提供的API method_setImplementation进行相同操作, 发现和以往一样, 毫无问题, 那么一定是做了一些处理, 查其源码, 发现了一个很可疑的函数 flushCaches, 见名知意, 清除缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static IMP </span><br><span class=\"line\">_method_setImplementation(Class cls, method_t *m, IMP imp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!m) return nil;</span><br><span class=\"line\">    if (!imp) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP old = m-&gt;imp;</span><br><span class=\"line\">    m-&gt;imp = imp;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Cache updates are slow if cls is nil (i.e. unknown)</span><br><span class=\"line\">    // RR/AWZ updates are slow if cls is nil (i.e. unknown)</span><br><span class=\"line\">    // fixme build list of classes whose Methods are known externally?</span><br><span class=\"line\"></span><br><span class=\"line\">    flushCaches(cls); </span><br><span class=\"line\"></span><br><span class=\"line\">    updateCustomRR_AWZ(cls, m);</span><br><span class=\"line\"></span><br><span class=\"line\">    return old;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/***********************************************************************</span><br><span class=\"line\">* _objc_flush_caches</span><br><span class=\"line\">* Flushes all caches.</span><br><span class=\"line\">* (Historical behavior: flush caches for cls, its metaclass, </span><br><span class=\"line\">* and subclasses thereof. Nil flushes all classes.)</span><br><span class=\"line\">* Locking: acquires runtimeLock</span><br><span class=\"line\">**********************************************************************/</span><br><span class=\"line\">static void flushCaches(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_locker_t lock(cacheUpdateLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cls) &#123;</span><br><span class=\"line\">        foreach_realized_class_and_subclass(cls, ^(Class c)&#123; // 遍历子类</span><br><span class=\"line\">            cache_erase_nolock(c);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        foreach_realized_class_and_metaclass(^(Class c)&#123;</span><br><span class=\"line\">            cache_erase_nolock(c);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Reset this entire cache to the uncached lookup by reallocating it.</span><br><span class=\"line\">// This must not shrink the cache - that breaks the lock-free scheme.</span><br><span class=\"line\">void cache_erase_nolock(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cacheUpdateLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    cache_t *cache = getCache(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    mask_t capacity = cache-&gt;capacity();</span><br><span class=\"line\">    if (capacity &gt; 0  &amp;&amp;  cache-&gt;occupied() &gt; 0) &#123;</span><br><span class=\"line\">        auto oldBuckets = cache-&gt;buckets();</span><br><span class=\"line\">        auto buckets = emptyBucketsForCapacity(capacity);</span><br><span class=\"line\">        cache-&gt;setBucketsAndMask(buckets, capacity - 1); // also clears occupied</span><br><span class=\"line\"></span><br><span class=\"line\">        cache_collect_free(oldBuckets, capacity);</span><br><span class=\"line\">        cache_collect(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上述源码可知, 在flushCaches函数中, 这个函数会把当前类本身, 当前类的元类以及当前类的子类的方法缓存全部清空, 这里我们也可以自己验证一下, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">              </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果</span><br><span class=\"line\">        </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">//        method-&gt;imp = (IMP)hookedSayHello; // 直接复制imp指针</span><br><span class=\"line\"></span><br><span class=\"line\">        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;</span><br><span class=\"line\">        uint32_t cacheCount = clz-&gt;cache.capacity();</span><br><span class=\"line\">        NSLog(@&quot;cacheCount : %d&quot;, cacheCount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSInteger i = 0; i &lt; cacheCount; i++) &#123;</span><br><span class=\"line\">            char *key = (char *)((clz-&gt;cache._buckets + i)-&gt;_key);</span><br><span class=\"line\">            // 这里设置一下</span><br><span class=\"line\">            printf(&quot;%ld - %s\\n&quot;, i, key); // 测试</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用Runtime API method_setImplementation, 打印如下图所示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/method_setImplementation_cache.png\" alt=\"调用Runtime API method_setImplementation,cache被清除\"><br>当直接给imp指针赋值, 打印如下图所示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache.png\" alt=\"imp指针赋值,cache没被清除\"></p>\n<p>可以看出, 当直接给imp指针复制, 不清除方法缓存, 其中打印的sayHello正是我们hook的方法, 之前的疑惑也一扫而空, 虽然方法的imp指向发生了改变, 但是方法缓存中的sayHello对应的imp并没有发生改变。</p>\n<p>我们知道, Objective-C通过方法缓存来提升方法调用速度, 缓存中找不到, 再去类对象的方法列表中去查找, 调用后便加入到方法缓存中, 这点也可以通过objc_msgSend的源码来确认, objc_msgSend的源码是汇编实现的, 即使看不懂汇编也没事, 通过旁边的注释, 大概来看出来调用流程: 在方法缓存中寻找, 找到直接返回方法IMP, 否则调用__objc_msgSend_uncached, 去方法列表中查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// objc_msgSend, 除去一些nil验证检测后, 调用 CacheLookup LOOKUP</span><br><span class=\"line\">LLookup_GetIsaDone:</span><br><span class=\"line\">\tCacheLookup LOOKUP\t\t// returns imp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/// CacheLookup</span><br><span class=\"line\">\t.macro CacheHit</span><br><span class=\"line\">.if $0 == NORMAL</span><br><span class=\"line\">\tMESSENGER_END_FAST</span><br><span class=\"line\">\tbr\tx17\t\t\t// call imp</span><br><span class=\"line\">.elseif $0 == GETIMP</span><br><span class=\"line\">\tmov\tx0, x17\t\t\t// return imp</span><br><span class=\"line\">\tret</span><br><span class=\"line\">.elseif $0 == LOOKUP</span><br><span class=\"line\">\tret\t\t\t\t// return imp via x17</span><br><span class=\"line\">.else</span><br><span class=\"line\">.abort oops</span><br><span class=\"line\">.endif</span><br><span class=\"line\">.endmacro</span><br><span class=\"line\"></span><br><span class=\"line\">.macro CheckMiss</span><br><span class=\"line\">\t// miss if bucket-&gt;sel == 0</span><br><span class=\"line\">.if $0 == GETIMP</span><br><span class=\"line\">\tcbz\tx9, LGetImpMiss</span><br><span class=\"line\">.elseif $0 == NORMAL</span><br><span class=\"line\">\tcbz\tx9, __objc_msgSend_uncached</span><br><span class=\"line\">.elseif $0 == LOOKUP</span><br><span class=\"line\">\tcbz\tx9, __objc_msgLookup_uncached</span><br></pre></td></tr></table></figure>\n<h1 id=\"作怪到底–自己修改方法缓存对应的imp\"><a href=\"#作怪到底–自己修改方法缓存对应的imp\" class=\"headerlink\" title=\"作怪到底–自己修改方法缓存对应的imp\"></a>作怪到底–自己修改方法缓存对应的imp</h1><p>既然都到这里, 不妨尝试自己去修改方法缓存中对应imp。其实从Objective-C Runtime层面来说, 对象、方法、block等都是以结构体的形式存在内存中, 想去改对象的属性, 方法的实现会是block的实现, 都是要对它们的内存布局有所了解。</p>\n<p>前面的分析把疑惑基本解决了, 现在要做的就比较简单是了, 只需要将方法缓存以及其他需要用到的结构体如对象、方法等的结构抽出来, 自己声明一个结构体, 把需要用上的成员变量和方法带上即可, 不需要用上可以直接删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct bucket_t &#123;</span><br><span class=\"line\">    cache_key_t _key;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct cache_t &#123;</span><br><span class=\"line\">    bucket_t *_buckets;</span><br><span class=\"line\">    mask_t _mask;</span><br><span class=\"line\">    mask_t _occupied;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    struct bucket_t *buckets();</span><br><span class=\"line\">    mask_t mask();</span><br><span class=\"line\">    mask_t occupied();</span><br><span class=\"line\">    void incrementOccupied();</span><br><span class=\"line\">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class=\"line\">    void initializeToEmpty();</span><br><span class=\"line\">    </span><br><span class=\"line\">    mask_t capacity();</span><br><span class=\"line\">    bool isConstantEmptyCache();</span><br><span class=\"line\">    bool canBeFreed();</span><br><span class=\"line\">    </span><br><span class=\"line\">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class=\"line\">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class=\"line\">    </span><br><span class=\"line\">    void expand();</span><br><span class=\"line\">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class=\"line\">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class=\"line\">    </span><br><span class=\"line\">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接下来, 只需要将load方法中添加一点代码进行验证即可:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">//        Class aClass = self; // 不给self发消息, cache不会生成, 结果就和我们的预想一样</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果</span><br><span class=\"line\">        </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">        method-&gt;imp = (IMP)hookedSayHello;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // cache问题, 因为 已经和 imp缓存了, 直接会调用原来方法</span><br><span class=\"line\">        // method_setImplementation 中有个函数 flushCache -&gt; cache_erase_nolock, 会重新设置 cache</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 修改cache</span><br><span class=\"line\">        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;</span><br><span class=\"line\">        uint32_t cacheCount = clz-&gt;cache.capacity();</span><br><span class=\"line\">        NSLog(@&quot;cacheCount : %d&quot;, cacheCount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSInteger i = 0; i &lt; cacheCount; i++) &#123;</span><br><span class=\"line\">            char *key = (char *)((clz-&gt;cache._buckets + i)-&gt;_key);</span><br><span class=\"line\">            // 这里设置一下</span><br><span class=\"line\">            printf(&quot;%ld - %s\\n&quot;, i, key); // 测试</span><br><span class=\"line\">            </span><br><span class=\"line\">            if (key) &#123;</span><br><span class=\"line\">                NSString *selectorName = [NSString stringWithUTF8String:key];</span><br><span class=\"line\"></span><br><span class=\"line\">                if ([selectorName isEqualToString:@&quot;sayHello&quot;]) &#123;</span><br><span class=\"line\">                    (clz-&gt;cache._buckets + i)-&gt;_imp = (IMP)hookedSayHello;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache_and_change_cache_imp.png\" alt=\"自己修改cache\"></p>\n<p>发现打印的确实是我们希望的实现, 当然这里只是一个简单的类, 对于有子类的情况没做验证, 如果有子类的情况下, 还是比较复杂的, 对于子类是否实现了该方法也是有区别的, 这也许也是 method_setImplementation 直接暴力地将当前类和子类的缓存都清空的原因吧!</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过本次探索, 对方法调用以及底层的一些流程有了一定的了解, 虽然对于开发确实没太大帮助, 但对于理解底层机制有一定帮助。在日常学习中, 可以配合源码, 通过自己的尝试, 一定可以对相关知识有更深刻地理解。</p>\n<p>代码地址: <a href=\"\">https://github.com/LoyalToOrigin/HookMethodWithLayout</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在iOS开发中, Method Swizzling想必大家都不陌生, 可以以此来对方法进行hook, 做一些我们希望做的事情, 比如页面进入退出, 可以对viewWillAppear及viewWillDisappear进行hook, 从而进行一些埋点日志相关的事情。</p>\n<p>那么, Method Swizzling的原理到底是怎样的呢? 这个问题, 即使没自己研究过, 大多数人也有所耳闻, 简单来说, 无非就是修改方法的imp指向, 让其指向我们hook的方法。如果是这样的话, 我们是否可以不用Runtime提供的API如method_setImplementation、method_exchangeImplementation等函数而通过对象及方法的内存布局来实现呢? 答案是肯定的, 下面便是我在此过程中的一些探索和理解。</p>\n<p>本文描述大部分内容对开发没有太大帮助, 但是对于更加了解运行时方法调用有一定帮助。</p>\n<h1 id=\"直接赋值Method的IMP进行hook\"><a href=\"#直接赋值Method的IMP进行hook\" class=\"headerlink\" title=\"直接赋值Method的IMP进行hook\"></a>直接赋值Method的IMP进行hook</h1><p>要想通过方法的内存布局来修改, 一定要对方法的内存布局有所了解, 查看源码可以知道Method的内存布局如下所示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct method_t &#123;</span><br><span class=\"line\">    SEL name;</span><br><span class=\"line\">    const char *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\"></span><br><span class=\"line\">    struct SortBySELAddress :</span><br><span class=\"line\">        public std::binary_function&lt;const method_t&amp;,</span><br><span class=\"line\">                                    const method_t&amp;, bool&gt;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bool operator() (const method_t&amp; lhs,</span><br><span class=\"line\">                         const method_t&amp; rhs)</span><br><span class=\"line\">        &#123; return lhs.name &lt; rhs.name; &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上面结构中, 很容易就找到我们想要的东西IMP, 话不多少, 赶紧进行hook。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@implementation Person</span><br><span class=\"line\"></span><br><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">       </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">        method-&gt;imp = (IMP)hookedSayHello;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)sayHello &#123;</span><br><span class=\"line\">    NSLog(@&quot;Hello, everybody!&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void hookedSayHello (id self, SEL _cmd, ...) &#123;</span><br><span class=\"line\">    NSLog(@&quot;This is hooked sayHello&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>然后再main.m中调用:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Person *person = [[Person alloc] init];</span><br><span class=\"line\">[person sayHello];</span><br></pre></td></tr></table></figure>\n<h3 id=\"遇到的问题-还是调用原来的方法实现\"><a href=\"#遇到的问题-还是调用原来的方法实现\" class=\"headerlink\" title=\"遇到的问题, 还是调用原来的方法实现\"></a>遇到的问题, 还是调用原来的方法实现</h3><p>此时却发现, 打印出来的却和我想象不太一样, 仍然是调用了原来的sayHello方法, 而且打个断点发现method的imp指针也确实指向了 void hookedSayHello (id self, SEL _cmd, …) 这个函数,  这确实有些让人捉摸不透。 </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/hooked_imp.png\" alt=\"直接修改方法imp\"></p>\n<h3 id=\"浅尝辄止–method-setImplementation\"><a href=\"#浅尝辄止–method-setImplementation\" class=\"headerlink\" title=\"浅尝辄止–method _setImplementation\"></a>浅尝辄止–method _setImplementation</h3><p>于是怀疑人生的我, 又使用Runtime提供的API method_setImplementation进行相同操作, 发现和以往一样, 毫无问题, 那么一定是做了一些处理, 查其源码, 发现了一个很可疑的函数 flushCaches, 见名知意, 清除缓存。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static IMP </span><br><span class=\"line\">_method_setImplementation(Class cls, method_t *m, IMP imp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!m) return nil;</span><br><span class=\"line\">    if (!imp) return nil;</span><br><span class=\"line\"></span><br><span class=\"line\">    IMP old = m-&gt;imp;</span><br><span class=\"line\">    m-&gt;imp = imp;</span><br><span class=\"line\"></span><br><span class=\"line\">    // Cache updates are slow if cls is nil (i.e. unknown)</span><br><span class=\"line\">    // RR/AWZ updates are slow if cls is nil (i.e. unknown)</span><br><span class=\"line\">    // fixme build list of classes whose Methods are known externally?</span><br><span class=\"line\"></span><br><span class=\"line\">    flushCaches(cls); </span><br><span class=\"line\"></span><br><span class=\"line\">    updateCustomRR_AWZ(cls, m);</span><br><span class=\"line\"></span><br><span class=\"line\">    return old;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/***********************************************************************</span><br><span class=\"line\">* _objc_flush_caches</span><br><span class=\"line\">* Flushes all caches.</span><br><span class=\"line\">* (Historical behavior: flush caches for cls, its metaclass, </span><br><span class=\"line\">* and subclasses thereof. Nil flushes all classes.)</span><br><span class=\"line\">* Locking: acquires runtimeLock</span><br><span class=\"line\">**********************************************************************/</span><br><span class=\"line\">static void flushCaches(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    runtimeLock.assertWriting();</span><br><span class=\"line\"></span><br><span class=\"line\">    mutex_locker_t lock(cacheUpdateLock);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (cls) &#123;</span><br><span class=\"line\">        foreach_realized_class_and_subclass(cls, ^(Class c)&#123; // 遍历子类</span><br><span class=\"line\">            cache_erase_nolock(c);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        foreach_realized_class_and_metaclass(^(Class c)&#123;</span><br><span class=\"line\">            cache_erase_nolock(c);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Reset this entire cache to the uncached lookup by reallocating it.</span><br><span class=\"line\">// This must not shrink the cache - that breaks the lock-free scheme.</span><br><span class=\"line\">void cache_erase_nolock(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cacheUpdateLock.assertLocked();</span><br><span class=\"line\"></span><br><span class=\"line\">    cache_t *cache = getCache(cls);</span><br><span class=\"line\"></span><br><span class=\"line\">    mask_t capacity = cache-&gt;capacity();</span><br><span class=\"line\">    if (capacity &gt; 0  &amp;&amp;  cache-&gt;occupied() &gt; 0) &#123;</span><br><span class=\"line\">        auto oldBuckets = cache-&gt;buckets();</span><br><span class=\"line\">        auto buckets = emptyBucketsForCapacity(capacity);</span><br><span class=\"line\">        cache-&gt;setBucketsAndMask(buckets, capacity - 1); // also clears occupied</span><br><span class=\"line\"></span><br><span class=\"line\">        cache_collect_free(oldBuckets, capacity);</span><br><span class=\"line\">        cache_collect(false);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上述源码可知, 在flushCaches函数中, 这个函数会把当前类本身, 当前类的元类以及当前类的子类的方法缓存全部清空, 这里我们也可以自己验证一下, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">              </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果</span><br><span class=\"line\">        </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">//        method-&gt;imp = (IMP)hookedSayHello; // 直接复制imp指针</span><br><span class=\"line\"></span><br><span class=\"line\">        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;</span><br><span class=\"line\">        uint32_t cacheCount = clz-&gt;cache.capacity();</span><br><span class=\"line\">        NSLog(@&quot;cacheCount : %d&quot;, cacheCount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSInteger i = 0; i &lt; cacheCount; i++) &#123;</span><br><span class=\"line\">            char *key = (char *)((clz-&gt;cache._buckets + i)-&gt;_key);</span><br><span class=\"line\">            // 这里设置一下</span><br><span class=\"line\">            printf(&quot;%ld - %s\\n&quot;, i, key); // 测试</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当调用Runtime API method_setImplementation, 打印如下图所示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/method_setImplementation_cache.png\" alt=\"调用Runtime API method_setImplementation,cache被清除\"><br>当直接给imp指针赋值, 打印如下图所示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache.png\" alt=\"imp指针赋值,cache没被清除\"></p>\n<p>可以看出, 当直接给imp指针复制, 不清除方法缓存, 其中打印的sayHello正是我们hook的方法, 之前的疑惑也一扫而空, 虽然方法的imp指向发生了改变, 但是方法缓存中的sayHello对应的imp并没有发生改变。</p>\n<p>我们知道, Objective-C通过方法缓存来提升方法调用速度, 缓存中找不到, 再去类对象的方法列表中去查找, 调用后便加入到方法缓存中, 这点也可以通过objc_msgSend的源码来确认, objc_msgSend的源码是汇编实现的, 即使看不懂汇编也没事, 通过旁边的注释, 大概来看出来调用流程: 在方法缓存中寻找, 找到直接返回方法IMP, 否则调用__objc_msgSend_uncached, 去方法列表中查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/// objc_msgSend, 除去一些nil验证检测后, 调用 CacheLookup LOOKUP</span><br><span class=\"line\">LLookup_GetIsaDone:</span><br><span class=\"line\">\tCacheLookup LOOKUP\t\t// returns imp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">/// CacheLookup</span><br><span class=\"line\">\t.macro CacheHit</span><br><span class=\"line\">.if $0 == NORMAL</span><br><span class=\"line\">\tMESSENGER_END_FAST</span><br><span class=\"line\">\tbr\tx17\t\t\t// call imp</span><br><span class=\"line\">.elseif $0 == GETIMP</span><br><span class=\"line\">\tmov\tx0, x17\t\t\t// return imp</span><br><span class=\"line\">\tret</span><br><span class=\"line\">.elseif $0 == LOOKUP</span><br><span class=\"line\">\tret\t\t\t\t// return imp via x17</span><br><span class=\"line\">.else</span><br><span class=\"line\">.abort oops</span><br><span class=\"line\">.endif</span><br><span class=\"line\">.endmacro</span><br><span class=\"line\"></span><br><span class=\"line\">.macro CheckMiss</span><br><span class=\"line\">\t// miss if bucket-&gt;sel == 0</span><br><span class=\"line\">.if $0 == GETIMP</span><br><span class=\"line\">\tcbz\tx9, LGetImpMiss</span><br><span class=\"line\">.elseif $0 == NORMAL</span><br><span class=\"line\">\tcbz\tx9, __objc_msgSend_uncached</span><br><span class=\"line\">.elseif $0 == LOOKUP</span><br><span class=\"line\">\tcbz\tx9, __objc_msgLookup_uncached</span><br></pre></td></tr></table></figure>\n<h1 id=\"作怪到底–自己修改方法缓存对应的imp\"><a href=\"#作怪到底–自己修改方法缓存对应的imp\" class=\"headerlink\" title=\"作怪到底–自己修改方法缓存对应的imp\"></a>作怪到底–自己修改方法缓存对应的imp</h1><p>既然都到这里, 不妨尝试自己去修改方法缓存中对应imp。其实从Objective-C Runtime层面来说, 对象、方法、block等都是以结构体的形式存在内存中, 想去改对象的属性, 方法的实现会是block的实现, 都是要对它们的内存布局有所了解。</p>\n<p>前面的分析把疑惑基本解决了, 现在要做的就比较简单是了, 只需要将方法缓存以及其他需要用到的结构体如对象、方法等的结构抽出来, 自己声明一个结构体, 把需要用上的成员变量和方法带上即可, 不需要用上可以直接删除。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct bucket_t &#123;</span><br><span class=\"line\">    cache_key_t _key;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">struct cache_t &#123;</span><br><span class=\"line\">    bucket_t *_buckets;</span><br><span class=\"line\">    mask_t _mask;</span><br><span class=\"line\">    mask_t _occupied;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    struct bucket_t *buckets();</span><br><span class=\"line\">    mask_t mask();</span><br><span class=\"line\">    mask_t occupied();</span><br><span class=\"line\">    void incrementOccupied();</span><br><span class=\"line\">    void setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask);</span><br><span class=\"line\">    void initializeToEmpty();</span><br><span class=\"line\">    </span><br><span class=\"line\">    mask_t capacity();</span><br><span class=\"line\">    bool isConstantEmptyCache();</span><br><span class=\"line\">    bool canBeFreed();</span><br><span class=\"line\">    </span><br><span class=\"line\">    static size_t bytesForCapacity(uint32_t cap);</span><br><span class=\"line\">    static struct bucket_t * endMarker(struct bucket_t *b, uint32_t cap);</span><br><span class=\"line\">    </span><br><span class=\"line\">    void expand();</span><br><span class=\"line\">    void reallocate(mask_t oldCapacity, mask_t newCapacity);</span><br><span class=\"line\">    struct bucket_t * find(cache_key_t key, id receiver);</span><br><span class=\"line\">    </span><br><span class=\"line\">    static void bad_cache(id receiver, SEL sel, Class isa) __attribute__((noreturn));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>接下来, 只需要将load方法中添加一点代码进行验证即可:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (void)load &#123;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        Class aClass = [self class];</span><br><span class=\"line\">//        Class aClass = self; // 不给self发消息, cache不会生成, 结果就和我们的预想一样</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = @selector(sayHello);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(aClass, originalSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">//        method_setImplementation(originalMethod, (IMP)hookedSayHello); //Runtime API, 可以发现cache被清除了, 可以打开注释, 验证结果</span><br><span class=\"line\">        </span><br><span class=\"line\">        struct method_t *method = (struct method_t *)originalMethod;</span><br><span class=\"line\">        method-&gt;imp = (IMP)hookedSayHello;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // cache问题, 因为 已经和 imp缓存了, 直接会调用原来方法</span><br><span class=\"line\">        // method_setImplementation 中有个函数 flushCache -&gt; cache_erase_nolock, 会重新设置 cache</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 修改cache</span><br><span class=\"line\">        struct my_objc_class *clz = (__bridge struct my_objc_class *)aClass;</span><br><span class=\"line\">        uint32_t cacheCount = clz-&gt;cache.capacity();</span><br><span class=\"line\">        NSLog(@&quot;cacheCount : %d&quot;, cacheCount);</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        for (NSInteger i = 0; i &lt; cacheCount; i++) &#123;</span><br><span class=\"line\">            char *key = (char *)((clz-&gt;cache._buckets + i)-&gt;_key);</span><br><span class=\"line\">            // 这里设置一下</span><br><span class=\"line\">            printf(&quot;%ld - %s\\n&quot;, i, key); // 测试</span><br><span class=\"line\">            </span><br><span class=\"line\">            if (key) &#123;</span><br><span class=\"line\">                NSString *selectorName = [NSString stringWithUTF8String:key];</span><br><span class=\"line\"></span><br><span class=\"line\">                if ([selectorName isEqualToString:@&quot;sayHello&quot;]) &#123;</span><br><span class=\"line\">                    (clz-&gt;cache._buckets + i)-&gt;_imp = (IMP)hookedSayHello;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E9%80%9A%E8%BF%87Method%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80hook%E6%96%B9%E6%B3%95%E6%8E%A2%E7%B4%A2/direct_imp_cache_and_change_cache_imp.png\" alt=\"自己修改cache\"></p>\n<p>发现打印的确实是我们希望的实现, 当然这里只是一个简单的类, 对于有子类的情况没做验证, 如果有子类的情况下, 还是比较复杂的, 对于子类是否实现了该方法也是有区别的, 这也许也是 method_setImplementation 直接暴力地将当前类和子类的缓存都清空的原因吧!</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>通过本次探索, 对方法调用以及底层的一些流程有了一定的了解, 虽然对于开发确实没太大帮助, 但对于理解底层机制有一定帮助。在日常学习中, 可以配合源码, 通过自己的尝试, 一定可以对相关知识有更深刻地理解。</p>\n<p>代码地址: <a href=\"\">https://github.com/LoyalToOrigin/HookMethodWithLayout</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}