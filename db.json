{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/_config.yml","hash":"c3a1694c111e2e1f05a174bd893fe951038fbda2","modified":1523087707695},{"_id":"themes/hexo-theme-yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1523087707695},{"_id":"themes/hexo-theme-yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1523087707711},{"_id":"themes/hexo-theme-yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1523087707694},{"_id":"themes/hexo-theme-yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1523087707742},{"_id":"source/_posts/Masonry源码解读.md","hash":"6401259961c62088e1188e55effc63f2419b2a2f","modified":1523368382714},{"_id":"source/_posts/iOS自动化打包之重签名导出不同证书ipa探索.md","hash":"7a4c1754f1c0c1a5e527d25d24fd59f44279f193","modified":1523094849988},{"_id":"themes/hexo-theme-yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1523087707685},{"_id":"themes/hexo-theme-yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1523087707686},{"_id":"themes/hexo-theme-yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1523087445230},{"_id":"source/_posts/hello-world.md","hash":"632c8991709ecc3ff6077bffe8a8ddfa3165547b","modified":1523094813024},{"_id":"themes/hexo-theme-yilia/.git/index","hash":"45e2f87ac79c1b992ee86729ae4077af3349f74f","modified":1523087992974},{"_id":"source/_posts/关于iOS自动化打包的一些分享.md","hash":"9fb59a93042632cf8ff1ede03c1df128507248f6","modified":1523094840448},{"_id":"themes/hexo-theme-yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1523087707683},{"_id":"themes/hexo-theme-yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1523087707696},{"_id":"themes/hexo-theme-yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1523087707696},{"_id":"themes/hexo-theme-yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1523087707696},{"_id":"themes/hexo-theme-yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1523087707696},{"_id":"themes/hexo-theme-yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1523087707697},{"_id":"themes/hexo-theme-yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1523087707697},{"_id":"themes/hexo-theme-yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1523087707697},{"_id":"themes/hexo-theme-yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1523087707709},{"_id":"themes/hexo-theme-yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1523087707710},{"_id":"themes/hexo-theme-yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1523087707709},{"_id":"themes/hexo-theme-yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1523087707709},{"_id":"themes/hexo-theme-yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1523087707710},{"_id":"themes/hexo-theme-yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1523087707710},{"_id":"themes/hexo-theme-yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1523087707710},{"_id":"themes/hexo-theme-yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1523087707737},{"_id":"themes/hexo-theme-yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1523087707741},{"_id":"themes/hexo-theme-yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1523087707711},{"_id":"themes/hexo-theme-yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1523087707732},{"_id":"themes/hexo-theme-yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523087707708},{"_id":"themes/hexo-theme-yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1523087707739},{"_id":"themes/hexo-theme-yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1523087707740},{"_id":"themes/hexo-theme-yilia/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1523087445230},{"_id":"themes/hexo-theme-yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1523087445232},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1523087445233},{"_id":"themes/hexo-theme-yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1523087445233},{"_id":"themes/hexo-theme-yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1523087445231},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1523087445232},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1523087445234},{"_id":"themes/hexo-theme-yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1523087445233},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1523087445231},{"_id":"themes/hexo-theme-yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1523087445232},{"_id":"themes/hexo-theme-yilia/.git/logs/HEAD","hash":"d7c49682c75dcb208ad25776e1b8b2b033f1a091","modified":1523087707686},{"_id":"themes/hexo-theme-yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1523087445234},{"_id":"themes/hexo-theme-yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1523087707698},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1523087707699},{"_id":"themes/hexo-theme-yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1523087707699},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1523087707699},{"_id":"themes/hexo-theme-yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1523087707700},{"_id":"themes/hexo-theme-yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1523087707700},{"_id":"themes/hexo-theme-yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1523087707700},{"_id":"themes/hexo-theme-yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1523087707700},{"_id":"themes/hexo-theme-yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1523087707701},{"_id":"themes/hexo-theme-yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1523087707701},{"_id":"themes/hexo-theme-yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1523087707701},{"_id":"themes/hexo-theme-yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1523087707702},{"_id":"themes/hexo-theme-yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1523087707702},{"_id":"themes/hexo-theme-yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1523087707703},{"_id":"themes/hexo-theme-yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1523087707708},{"_id":"themes/hexo-theme-yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1523087707709},{"_id":"themes/hexo-theme-yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1523087707733},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1523087707734},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1523087707735},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1523087707734},{"_id":"themes/hexo-theme-yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1523087707735},{"_id":"themes/hexo-theme-yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1523087707736},{"_id":"themes/hexo-theme-yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1523087707735},{"_id":"themes/hexo-theme-yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1523087707736},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1523087707736},{"_id":"themes/hexo-theme-yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1523087707712},{"_id":"themes/hexo-theme-yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1523087707712},{"_id":"themes/hexo-theme-yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1523087707712},{"_id":"themes/hexo-theme-yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1523087707713},{"_id":"themes/hexo-theme-yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1523087707713},{"_id":"themes/hexo-theme-yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1523087707714},{"_id":"themes/hexo-theme-yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1523087707714},{"_id":"themes/hexo-theme-yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1523087707714},{"_id":"themes/hexo-theme-yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1523087707715},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1523087707717},{"_id":"themes/hexo-theme-yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1523087707720},{"_id":"themes/hexo-theme-yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1523087707720},{"_id":"themes/hexo-theme-yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1523087707721},{"_id":"themes/hexo-theme-yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1523087707720},{"_id":"themes/hexo-theme-yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1523087707722},{"_id":"themes/hexo-theme-yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1523087707723},{"_id":"themes/hexo-theme-yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1523087707723},{"_id":"themes/hexo-theme-yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1523087707723},{"_id":"themes/hexo-theme-yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1523087707724},{"_id":"themes/hexo-theme-yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1523087707724},{"_id":"themes/hexo-theme-yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1523087707724},{"_id":"themes/hexo-theme-yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1523087707724},{"_id":"themes/hexo-theme-yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1523087707725},{"_id":"themes/hexo-theme-yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1523087707725},{"_id":"themes/hexo-theme-yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1523087707725},{"_id":"themes/hexo-theme-yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1523087707726},{"_id":"themes/hexo-theme-yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1523087707726},{"_id":"themes/hexo-theme-yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1523087707727},{"_id":"themes/hexo-theme-yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1523087707728},{"_id":"themes/hexo-theme-yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1523087707728},{"_id":"themes/hexo-theme-yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1523087707729},{"_id":"themes/hexo-theme-yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1523087707727},{"_id":"themes/hexo-theme-yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1523087707730},{"_id":"themes/hexo-theme-yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1523087707730},{"_id":"themes/hexo-theme-yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1523087707730},{"_id":"themes/hexo-theme-yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1523087707731},{"_id":"themes/hexo-theme-yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1523087707731},{"_id":"themes/hexo-theme-yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1523087707732},{"_id":"themes/hexo-theme-yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1523087707732},{"_id":"themes/hexo-theme-yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1523087707708},{"_id":"themes/hexo-theme-yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1523087707685},{"_id":"themes/hexo-theme-yilia/.git/objects/pack/pack-a4a024724a50ae1e8ea0e0deab1aba91916d1344.idx","hash":"66fb8f29773daff89e17aceb7d91f5e53c6b8d47","modified":1523087707666},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1523087707704},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1523087707704},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1523087707703},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1523087707705},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1523087707705},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1523087707706},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1523087707706},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1523087707705},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1523087707706},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1523087707706},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1523087707715},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1523087707716},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1523087707717},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1523087707716},{"_id":"themes/hexo-theme-yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1523087707717},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1523087707718},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1523087707718},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1523087707719},{"_id":"themes/hexo-theme-yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1523087707722},{"_id":"themes/hexo-theme-yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1523087707722},{"_id":"themes/hexo-theme-yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1523087707721},{"_id":"themes/hexo-theme-yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1523087707720},{"_id":"themes/hexo-theme-yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1523087707685},{"_id":"themes/hexo-theme-yilia/.git/logs/refs/heads/master","hash":"d7c49682c75dcb208ad25776e1b8b2b033f1a091","modified":1523087707686},{"_id":"themes/hexo-theme-yilia/.git/logs/refs/remotes/origin/HEAD","hash":"d7c49682c75dcb208ad25776e1b8b2b033f1a091","modified":1523087707684},{"_id":"themes/hexo-theme-yilia/.git/objects/pack/pack-a4a024724a50ae1e8ea0e0deab1aba91916d1344.pack","hash":"ad13c03f734dc6b2649043501fed63bd1714bfc3","modified":1523087707664},{"_id":"public/2018/03/08/iOS自动化打包之重签名导出不同证书ipa探索/index.html","hash":"c0dd5f788b67b6bfe0e672528424b41f9417f774","modified":1523440413490},{"_id":"public/2018/01/11/Masonry源码解读/index.html","hash":"75858c26dd46846f9d362e31a62623560374304f","modified":1523440413493},{"_id":"public/2018/01/11/关于iOS自动化打包的一些分享/index.html","hash":"e6effbfd1591f5316bd1db4f38b2821db69f70ff","modified":1523440413494},{"_id":"public/2017/12/29/hello-world/index.html","hash":"e1da71638b13e08cb77f0840c2d7a66f725c87a9","modified":1523440413494},{"_id":"public/archives/index.html","hash":"51beb40d945e747b66328e57c906dbc28512e17e","modified":1523440413494},{"_id":"public/archives/2017/index.html","hash":"8b9cff161e0dc602b4d53db717d567d355bb4f73","modified":1523440413494},{"_id":"public/archives/2018/index.html","hash":"7938d4d6fa793b8313bbff7eb233903bd61ff785","modified":1523440413494},{"_id":"public/archives/2018/01/index.html","hash":"8cf436709588b4751f5978dd37dcdc96ae1728f7","modified":1523440413495},{"_id":"public/archives/2018/03/index.html","hash":"1b1fb10c857bf7615dcbb07c6e127ceffc1471d4","modified":1523440413495},{"_id":"public/index.html","hash":"ee04745f003bfe48083fa6fde8821ff86e040406","modified":1523440413495},{"_id":"public/archives/2017/12/index.html","hash":"1a12bb7b15509e399fb59ea7c96b8299ea69f8f4","modified":1523440413498},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1523440413501},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1523440413501},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1523440413501},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1523440413501},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1523440413501},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1523440413501},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1523440413502},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1523440413502},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1523440413502},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1523440413506},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1523440413506},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1523440413506},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1523440413506}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Masonry源码解读","date":"2018-01-10T16:00:00.000Z","_content":"\n\n","source":"_posts/Masonry源码解读.md","raw":"---\ntitle: Masonry源码解读\ndate: 2018-01-11\ncategories: \n---\n\n\n","slug":"Masonry源码解读","published":1,"updated":"2018-04-10T13:53:02.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfux35sq0000b1zy2fjz3061","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"iOS自动化打包之重签名导出不同证书ipa探索","date":"2018-03-07T16:00:00.000Z","_content":"\n在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。\n\n所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。\n\n我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。\n\n因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。\n\n本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。\n\n\n# 对ipa进行重签名\n\n起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。\n\n我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。\n \n\n# 不等导出ipa，修改.xcarchive文件\n\n.xcarchive文件是对项目进行手动archive，或执行以下脚本:\n\n```\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationDistribution} -archivePath ${archivePath}\n```\n\n如果对打包命令不是很了解的，可以查看我的上一篇文章文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n\n首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png)\n\n我们可以看到里面有一些App必需的属性。\n\n\n## 1. 修改 .xcarchive 的 Info.plist\n\n此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png)\n\n\n## 2. 修改 App Extension 相关信息\n\n此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 **修改主target相关信息** 。\n\n通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png)\n\n\n### 2.1 修改 Info.plist 相关信息\n\nApp Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。\n\n修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 **com.test.www** ，这里便是 **com.test.www.notificationserviceextension**。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png)\n\n### 2.2 替换 Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 2.3 修改 archived-expanded-entitlements.xcent\n\n我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，\n格式是 **teamId.bundle identifier** 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png)\n\n修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。\n\n### 2.4 重签名\n\n用对应的证书对 App Extension 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppNameNotificationServiceExtension.appex\n```\n\n\n## 3. 修改主target相关信息\n\n与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。\n\n### 3.1 修改Info.plist的相关信息\n\n进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。\n\n你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。\n\n### 3.2 替换Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 3.3 重签名\n\n用对应的证书对 .app文件 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppName.app\n```\n\n## 4. 导出包\n\n```\nxcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath\n```\n成功后，命令台输出:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png)\n\n如果对于 **exportOptionsPlist** 不了解的，也可以看我的上篇文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n。\n\n# 注意点\n\n上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。\n\n我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。\n大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。\n\n# 总结\n\n经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。\n\n\n\n\n\n","source":"_posts/iOS自动化打包之重签名导出不同证书ipa探索.md","raw":"---\ntitle: iOS自动化打包之重签名导出不同证书ipa探索\ndate: 2018-03-08\ncategories: \n---\n\n在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。\n\n所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。\n\n我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。\n\n因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。\n\n本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。\n\n\n# 对ipa进行重签名\n\n起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。\n\n我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。\n \n\n# 不等导出ipa，修改.xcarchive文件\n\n.xcarchive文件是对项目进行手动archive，或执行以下脚本:\n\n```\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationDistribution} -archivePath ${archivePath}\n```\n\n如果对打包命令不是很了解的，可以查看我的上一篇文章文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n\n首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png)\n\n我们可以看到里面有一些App必需的属性。\n\n\n## 1. 修改 .xcarchive 的 Info.plist\n\n此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png)\n\n\n## 2. 修改 App Extension 相关信息\n\n此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 **修改主target相关信息** 。\n\n通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png)\n\n\n### 2.1 修改 Info.plist 相关信息\n\nApp Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。\n\n修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 **com.test.www** ，这里便是 **com.test.www.notificationserviceextension**。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png)\n\n### 2.2 替换 Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 2.3 修改 archived-expanded-entitlements.xcent\n\n我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，\n格式是 **teamId.bundle identifier** 。\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png)\n\n修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。\n\n### 2.4 重签名\n\n用对应的证书对 App Extension 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppNameNotificationServiceExtension.appex\n```\n\n\n## 3. 修改主target相关信息\n\n与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。\n\n### 3.1 修改Info.plist的相关信息\n\n进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。\n\n你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。\n\n### 3.2 替换Provisioning Profile\n\n将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 **embedded.mobileprovision** 。\n\n\n### 3.3 重签名\n\n用对应的证书对 .app文件 重新签名，这里的 **YourCetificateName** 依旧是修改 .xcarchive的Info.plist 里的证书名。\n\n```\ncodesign -f -s \"YourCetificateName\" YourAppName.app\n```\n\n## 4. 导出包\n\n```\nxcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath\n```\n成功后，命令台输出:\n\n![](http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png)\n\n如果对于 **exportOptionsPlist** 不了解的，也可以看我的上篇文章:[关于iOS自动化打包的一些分享](https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/)\n。\n\n# 注意点\n\n上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。\n\n我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。\n大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。\n\n# 总结\n\n经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。\n\n\n\n\n\n","slug":"iOS自动化打包之重签名导出不同证书ipa探索","published":1,"updated":"2018-04-07T09:54:09.988Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfux35sw0001b1zyvkt59vzb","content":"<p>在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。</p>\n<p>所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。</p>\n<p>我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。</p>\n<p>因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。</p>\n<p>本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。</p>\n<h1 id=\"对ipa进行重签名\"><a href=\"#对ipa进行重签名\" class=\"headerlink\" title=\"对ipa进行重签名\"></a>对ipa进行重签名</h1><p>起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。</p>\n<p>我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。</p>\n<h1 id=\"不等导出ipa，修改-xcarchive文件\"><a href=\"#不等导出ipa，修改-xcarchive文件\" class=\"headerlink\" title=\"不等导出ipa，修改.xcarchive文件\"></a>不等导出ipa，修改.xcarchive文件</h1><p>.xcarchive文件是对项目进行手动archive，或执行以下脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationDistribution&#125; -archivePath $&#123;archivePath&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对打包命令不是很了解的，可以查看我的上一篇文章文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a></p>\n<p>首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png\" alt=\"\"></p>\n<p>我们可以看到里面有一些App必需的属性。</p>\n<h2 id=\"1-修改-xcarchive-的-Info-plist\"><a href=\"#1-修改-xcarchive-的-Info-plist\" class=\"headerlink\" title=\"1. 修改 .xcarchive 的 Info.plist\"></a>1. 修改 .xcarchive 的 Info.plist</h2><p>此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png\" alt=\"\"></p>\n<h2 id=\"2-修改-App-Extension-相关信息\"><a href=\"#2-修改-App-Extension-相关信息\" class=\"headerlink\" title=\"2. 修改 App Extension 相关信息\"></a>2. 修改 App Extension 相关信息</h2><p>此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 <strong>修改主target相关信息</strong> 。</p>\n<p>通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png\" alt=\"\"></p>\n<h3 id=\"2-1-修改-Info-plist-相关信息\"><a href=\"#2-1-修改-Info-plist-相关信息\" class=\"headerlink\" title=\"2.1 修改 Info.plist 相关信息\"></a>2.1 修改 Info.plist 相关信息</h3><p>App Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。</p>\n<p>修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 <strong>com.test.www</strong> ，这里便是 <strong>com.test.<a href=\"http://www.notificationserviceextension\" target=\"_blank\" rel=\"noopener\">www.notificationserviceextension</a></strong>。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png\" alt=\"\"></p>\n<h3 id=\"2-2-替换-Provisioning-Profile\"><a href=\"#2-2-替换-Provisioning-Profile\" class=\"headerlink\" title=\"2.2 替换 Provisioning Profile\"></a>2.2 替换 Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"2-3-修改-archived-expanded-entitlements-xcent\"><a href=\"#2-3-修改-archived-expanded-entitlements-xcent\" class=\"headerlink\" title=\"2.3 修改 archived-expanded-entitlements.xcent\"></a>2.3 修改 archived-expanded-entitlements.xcent</h3><p>我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，<br>格式是 <strong>teamId.bundle identifier</strong> 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png\" alt=\"\"></p>\n<p>修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。</p>\n<h3 id=\"2-4-重签名\"><a href=\"#2-4-重签名\" class=\"headerlink\" title=\"2.4 重签名\"></a>2.4 重签名</h3><p>用对应的证书对 App Extension 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppNameNotificationServiceExtension.appex</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-修改主target相关信息\"><a href=\"#3-修改主target相关信息\" class=\"headerlink\" title=\"3. 修改主target相关信息\"></a>3. 修改主target相关信息</h2><p>与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。</p>\n<h3 id=\"3-1-修改Info-plist的相关信息\"><a href=\"#3-1-修改Info-plist的相关信息\" class=\"headerlink\" title=\"3.1 修改Info.plist的相关信息\"></a>3.1 修改Info.plist的相关信息</h3><p>进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。</p>\n<p>你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。</p>\n<h3 id=\"3-2-替换Provisioning-Profile\"><a href=\"#3-2-替换Provisioning-Profile\" class=\"headerlink\" title=\"3.2 替换Provisioning Profile\"></a>3.2 替换Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"3-3-重签名\"><a href=\"#3-3-重签名\" class=\"headerlink\" title=\"3.3 重签名\"></a>3.3 重签名</h3><p>用对应的证书对 .app文件 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppName.app</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-导出包\"><a href=\"#4-导出包\" class=\"headerlink\" title=\"4. 导出包\"></a>4. 导出包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath</span><br></pre></td></tr></table></figure>\n<p>成功后，命令台输出:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png\" alt=\"\"></p>\n<p>如果对于 <strong>exportOptionsPlist</strong> 不了解的，也可以看我的上篇文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a><br>。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。</p>\n<p>我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。<br>大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在完成基础的自动包打包流程过后，随即也出现了日常中常见的问题，比如我们每次需要打出不同网络环境和不同证书的ipa，由于开发者可以添加的设备只有100个，而公司的几个项目都是用的一个账号，各项目组都是独立的，再加上期间加入设备的员工的离职，真正能参与测试的设备寥寥无几。</p>\n<p>所以我司一般测试都是使用企业证书，这样不同的项目都可以公用同一个证书，不仅管理起来方面，而且还摆脱了设备数量限制的烦恼，但另一方面，对于需要测试内购等功能的时候，仍然需要使用adhoc证书的包来进行测试。</p>\n<p>我们原先的打包策略是通过执行脚本时输入的参数来打对应的包，这样对于不同测试并行测试，一次就要打出好几个，以我司作为打包服务器 Mac Mini 来说，archive + export 一个包的时间约为20min，对于不同证书不同环境的包随机组合，一次打出4个不同的包的时间就要花费约1h20min，而且在打包的时候，如果其他同事修改了新的bug，也无法打包。</p>\n<p>因此，我们寻思能不能通过重签名的方式，只编译一次，对其重签名，打出不同的包。</p>\n<p>本文主要介绍我在此过程中的一些探索，旨在提高不同证书不同环境的打包效率。</p>\n<h1 id=\"对ipa进行重签名\"><a href=\"#对ipa进行重签名\" class=\"headerlink\" title=\"对ipa进行重签名\"></a>对ipa进行重签名</h1><p>起初，我在网上查阅了相关资料，按照相关教程，却最终以失败告终。 如果有同学直接对ipa进行重签名成功的，希望不吝赐教。</p>\n<p>我估摸着是不是内部做了什么验证，导致对ipa重签名无法成功。所以，我想可不可以不到ipa这步，更早地对其进行信息的修改以及重签名，权当一次尝试，即使失败也能在探索中学到新知识。最终，成功将原来打4个包需要1h20min的时间压缩到30min不到。</p>\n<h1 id=\"不等导出ipa，修改-xcarchive文件\"><a href=\"#不等导出ipa，修改-xcarchive文件\" class=\"headerlink\" title=\"不等导出ipa，修改.xcarchive文件\"></a>不等导出ipa，修改.xcarchive文件</h1><p>.xcarchive文件是对项目进行手动archive，或执行以下脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationDistribution&#125; -archivePath $&#123;archivePath&#125;</span><br></pre></td></tr></table></figure>\n<p>如果对打包命令不是很了解的，可以查看我的上一篇文章文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a></p>\n<p>首先，我们进入到 .xcarchive 文件目录，发现里面一个 Info.plist 文件，打开如下显示:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/xcarchive_infoplist.png\" alt=\"\"></p>\n<p>我们可以看到里面有一些App必需的属性。</p>\n<h2 id=\"1-修改-xcarchive-的-Info-plist\"><a href=\"#1-修改-xcarchive-的-Info-plist\" class=\"headerlink\" title=\"1. 修改 .xcarchive 的 Info.plist\"></a>1. 修改 .xcarchive 的 Info.plist</h2><p>此处，如果项目 Bundle Identifier 需要发生改变，则修改 CFBundleIdentifier 对应的值，并将 SigningIdentity 改成 Bundle Identifier 对应的证书，关于此处SigningIdentity的值，可在钥匙串中找到对应的证书，查看其信息，即为下图中(英文系统)的 Common Name 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/certificate_info.png\" alt=\"\"></p>\n<h2 id=\"2-修改-App-Extension-相关信息\"><a href=\"#2-修改-App-Extension-相关信息\" class=\"headerlink\" title=\"2. 修改 App Extension 相关信息\"></a>2. 修改 App Extension 相关信息</h2><p>此步是对于项目 target 中如 notification extension 等从属 target，如果没有 App Extension ，直接可以跳过此步，查看下一步 <strong>修改主target相关信息</strong> 。</p>\n<p>通过文件夹打开 YourAppName.xcarchive/Products/Applications/YourAppName.app/PlugIns/YourAppNameNotificationServiceExtension.appex ，这里不是标准文件夹，open 命令似乎不起作用，观察其目录结构:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_floder.png\" alt=\"\"></p>\n<h3 id=\"2-1-修改-Info-plist-相关信息\"><a href=\"#2-1-修改-Info-plist-相关信息\" class=\"headerlink\" title=\"2.1 修改 Info.plist 相关信息\"></a>2.1 修改 Info.plist 相关信息</h3><p>App Extension 的 Bundle Identifier 是 App 的 Bundle Identifier 加上其对应后缀，如 notificationserviceextension 。</p>\n<p>修改 Bundle Identifier 为对应的值，这里对应的值是指之前修改 .xcarchive 目录中 Info.plist 的 Bundle Identifier 对应，如 <strong>com.test.www</strong> ，这里便是 <strong>com.test.<a href=\"http://www.notificationserviceextension\" target=\"_blank\" rel=\"noopener\">www.notificationserviceextension</a></strong>。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_infoplist.png\" alt=\"\"></p>\n<h3 id=\"2-2-替换-Provisioning-Profile\"><a href=\"#2-2-替换-Provisioning-Profile\" class=\"headerlink\" title=\"2.2 替换 Provisioning Profile\"></a>2.2 替换 Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"2-3-修改-archived-expanded-entitlements-xcent\"><a href=\"#2-3-修改-archived-expanded-entitlements-xcent\" class=\"headerlink\" title=\"2.3 修改 archived-expanded-entitlements.xcent\"></a>2.3 修改 archived-expanded-entitlements.xcent</h3><p>我们通过xcode打开archived-expanded-entitlements.xcent，其本质就是plist文件，<br>格式是 <strong>teamId.bundle identifier</strong> 。</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/extension_archived-expanded-entitlements.png\" alt=\"\"></p>\n<p>修改图中遮盖的两项值，依旧是要和.xcarchive的Info.plist值对应。</p>\n<h3 id=\"2-4-重签名\"><a href=\"#2-4-重签名\" class=\"headerlink\" title=\"2.4 重签名\"></a>2.4 重签名</h3><p>用对应的证书对 App Extension 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppNameNotificationServiceExtension.appex</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-修改主target相关信息\"><a href=\"#3-修改主target相关信息\" class=\"headerlink\" title=\"3. 修改主target相关信息\"></a>3. 修改主target相关信息</h2><p>与上一步修改 App Extension 步骤基本相同，只是少一步，不用修改 archived-expanded-entitlements.xcent 。</p>\n<h3 id=\"3-1-修改Info-plist的相关信息\"><a href=\"#3-1-修改Info-plist的相关信息\" class=\"headerlink\" title=\"3.1 修改Info.plist的相关信息\"></a>3.1 修改Info.plist的相关信息</h3><p>进入.app目录，修改Info.plist的Bundle Identifier，使其与.xcarchive文件对应。</p>\n<p>你也可以修改其他一些值，如网络环境，是测试环境，还是生产环境，这里只是抛砖引玉。事实上，修改网络环境有方便的方法，如通过读取粘贴板的文本来切换，或者写一个辅助程序来打开我们的App，从而通知切换环境。</p>\n<h3 id=\"3-2-替换Provisioning-Profile\"><a href=\"#3-2-替换Provisioning-Profile\" class=\"headerlink\" title=\"3.2 替换Provisioning Profile\"></a>3.2 替换Provisioning Profile</h3><p>将对应的 Provisioning Profile 拷贝到该目录下替换原来的 Provisioning Profile ，改成相同的文件名 <strong>embedded.mobileprovision</strong> 。</p>\n<h3 id=\"3-3-重签名\"><a href=\"#3-3-重签名\" class=\"headerlink\" title=\"3.3 重签名\"></a>3.3 重签名</h3><p>用对应的证书对 .app文件 重新签名，这里的 <strong>YourCetificateName</strong> 依旧是修改 .xcarchive的Info.plist 里的证书名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codesign -f -s &quot;YourCetificateName&quot; YourAppName.app</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-导出包\"><a href=\"#4-导出包\" class=\"headerlink\" title=\"4. 导出包\"></a>4. 导出包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xcodebuild -exportArchive -archivePath YourAppName.xcarchive -exportPath $(pwd) -exportOptionsPlist YourExportOptionsPlistPath</span><br></pre></td></tr></table></figure>\n<p>成功后，命令台输出:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BAipa%E6%8E%A2%E7%B4%A2/export_succeed.png\" alt=\"\"></p>\n<p>如果对于 <strong>exportOptionsPlist</strong> 不了解的，也可以看我的上篇文章:<a href=\"https://loyaltoorigin.github.io/2018/01/01/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/\" target=\"_blank\" rel=\"noopener\">关于iOS自动化打包的一些分享</a><br>。</p>\n<h1 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h1><p>上述修改的每一步，无论是Bundler Identifer，还是Provisioning Profile，还是重签名用的证书，都是需要相对应的，如果有一步错了，ipa包是导不出来的。</p>\n<p>我的表述可能不是那么清楚，相信大家操作一次，一步一步来，修改需要修改的值，其实基本是一目了然的。<br>大家如果有类似需求，建议先操作一次，成功后再写脚本实现自动化。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>经过上述操作，实质上只进行了一次编译，然后修改相关信息，导出对应不同的证书的包，只是多做了几次导出操作，大大地节省了打包时间。大家如果有什么想法或更好的办法，欢迎一起讨论讨论。</p>\n"},{"title":"Hello World","date":"2017-12-28T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-12-29\ncategories: \n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2018-04-07T09:53:33.024Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfux35t40002b1zyvk37nv3j","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"关于iOS自动化打包的一些分享","date":"2018-01-10T16:00:00.000Z","_content":"\n说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。\n\n即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。\n\n本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。\n\n谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。\n\n## Server相比于jenkins，我总结优点有三: \n\n1. 相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；\n2. 直接使用xcode就可开始构建项目，而不需要登录网页；\n3. 集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。\n \n这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。\n\n下面我介绍使用过程中需要注意的一些方面: \n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png)\n\n如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。\n\n如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。\n\n上面所说的plist文件大体结构是这样的:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png)\n\n这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。\n\n在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，\nhttps://192.168.0.xxx/xcode/lastest 或 https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png)\n\n\n## 关于jenkins的一些配置注意事项:\n### 以下是我在配置过程中踩到的一些坑:\n\n1. 8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；\n2. git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png)\n\n接下来，其他用户直接通过浏览器登录 http://192.168.0.xxx:8082 ，通过账号密码登录，便可以配置和构建项目。\n\n### jenkins相对Mac OS Server的优点:\n\n1. 同一局域网便可以登录，登录之后便可以自行配置项目\n2. 似乎可以并行构建任务\n\n当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png)\n而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png)\n这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。\n\n但是jenkins有更方便的打包方式:\njenkins开启token，不需要用户名登录便可以打包:\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png)\n\n这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。\n系统管理->全局安全配置->勾选 Allow anonymous read access\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png)\n\n接着，我们便可以通过命令来打包:\n```\ncurl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&cause\\=testBuild\n```\n\n| 参数       \t\t\t\t\t\t| 注释    |\n| --------   \t\t\t\t\t\t| -----:   |\n| notification_extension_test | 项目名称     |\n| token       \t\t\t\t\t| 上面设置的token    |\n| cause        \t\t\t\t\t| 可选参数，可不传      |\n\n这样似乎可以用一台服务器，将打包任务部署到指定机器上:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png)\n这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。\n\n## 关于Server和jenkins的一些总结:\n1. 如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；\n2. 对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；\n3. 如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。\n\n## fastlane及打包脚本简单介绍\n说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:\n\n1. 避免繁琐的路径拼接，拷贝等\n2. 修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败\n\n我们来简单看一段fastlane的打包代码:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png)\n\n上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行\n\n```\nfastlane adhocMyApp version:100000  // 100000是传的版本号\n```\n便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png)\n\n发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png)\n\n我们再看终端，看看fastlane究竟做了些啥\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png)\n\n也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:\n\n```\n// 对应手动打包archive\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationRelease} -archivePath ${archivePath}\n// 对应导出步骤\nxcodebuild -exportArchive -archivePath ${archivePath} -exportPath ${exportPath} -exportOptionsPlist ${exportOptionsPlist}\n\n```\n\n上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。\n\n经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。\n\n## 总结\n本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。\n","source":"_posts/关于iOS自动化打包的一些分享.md","raw":"---\ntitle: 关于iOS自动化打包的一些分享\ndate: 2018-01-11\ncategories: \n---\n\n说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。\n\n即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。\n\n本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。\n\n谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。\n\n## Server相比于jenkins，我总结优点有三: \n\n1. 相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；\n2. 直接使用xcode就可开始构建项目，而不需要登录网页；\n3. 集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。\n \n这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。\n\n下面我介绍使用过程中需要注意的一些方面: \n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png)\n\n如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。\n\n如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。\n\n上面所说的plist文件大体结构是这样的:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png)\n\n这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。\n\n在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，\nhttps://192.168.0.xxx/xcode/lastest 或 https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png)\n\n\n## 关于jenkins的一些配置注意事项:\n### 以下是我在配置过程中踩到的一些坑:\n\n1. 8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；\n2. git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png)\n\n接下来，其他用户直接通过浏览器登录 http://192.168.0.xxx:8082 ，通过账号密码登录，便可以配置和构建项目。\n\n### jenkins相对Mac OS Server的优点:\n\n1. 同一局域网便可以登录，登录之后便可以自行配置项目\n2. 似乎可以并行构建任务\n\n当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png)\n而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png)\n这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。\n\n但是jenkins有更方便的打包方式:\njenkins开启token，不需要用户名登录便可以打包:\n\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png)\n\n这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。\n系统管理->全局安全配置->勾选 Allow anonymous read access\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png)\n\n接着，我们便可以通过命令来打包:\n```\ncurl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&cause\\=testBuild\n```\n\n| 参数       \t\t\t\t\t\t| 注释    |\n| --------   \t\t\t\t\t\t| -----:   |\n| notification_extension_test | 项目名称     |\n| token       \t\t\t\t\t| 上面设置的token    |\n| cause        \t\t\t\t\t| 可选参数，可不传      |\n\n这样似乎可以用一台服务器，将打包任务部署到指定机器上:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png)\n这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。\n\n## 关于Server和jenkins的一些总结:\n1. 如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；\n2. 对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；\n3. 如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。\n\n## fastlane及打包脚本简单介绍\n说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:\n\n1. 避免繁琐的路径拼接，拷贝等\n2. 修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败\n\n我们来简单看一段fastlane的打包代码:\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png)\n\n上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行\n\n```\nfastlane adhocMyApp version:100000  // 100000是传的版本号\n```\n便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png)\n\n发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png)\n\n我们再看终端，看看fastlane究竟做了些啥\n![](http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png)\n\n也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:\n\n```\n// 对应手动打包archive\nxcodebuild archive -workspace ${work_space} -scheme ${scheme} -configuration ${configurationRelease} -archivePath ${archivePath}\n// 对应导出步骤\nxcodebuild -exportArchive -archivePath ${archivePath} -exportPath ${exportPath} -exportOptionsPlist ${exportOptionsPlist}\n\n```\n\n上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。\n\n经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。\n\n## 总结\n本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。\n","slug":"关于iOS自动化打包的一些分享","published":1,"updated":"2018-04-07T09:54:00.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfux35t50003b1zy9myf39qu","content":"<p>说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。</p>\n<p>即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。</p>\n<p>本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。</p>\n<p>谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。</p>\n<h2 id=\"Server相比于jenkins，我总结优点有三\"><a href=\"#Server相比于jenkins，我总结优点有三\" class=\"headerlink\" title=\"Server相比于jenkins，我总结优点有三:\"></a>Server相比于jenkins，我总结优点有三:</h2><ol>\n<li>相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；</li>\n<li>直接使用xcode就可开始构建项目，而不需要登录网页；</li>\n<li>集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。</li>\n</ol>\n<p>这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。</p>\n<p>下面我介绍使用过程中需要注意的一些方面: </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png\" alt=\"\"></p>\n<p>如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。</p>\n<p>如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。</p>\n<p>上面所说的plist文件大体结构是这样的:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png\" alt=\"\"></p>\n<p>这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。</p>\n<p>在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，<br><a href=\"https://192.168.0.xxx/xcode/lastest\" target=\"_blank\" rel=\"noopener\">https://192.168.0.xxx/xcode/lastest</a> 或 <a href=\"https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\" target=\"_blank\" rel=\"noopener\">https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。</a><br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png\" alt=\"\"></p>\n<h2 id=\"关于jenkins的一些配置注意事项\"><a href=\"#关于jenkins的一些配置注意事项\" class=\"headerlink\" title=\"关于jenkins的一些配置注意事项:\"></a>关于jenkins的一些配置注意事项:</h2><h3 id=\"以下是我在配置过程中踩到的一些坑\"><a href=\"#以下是我在配置过程中踩到的一些坑\" class=\"headerlink\" title=\"以下是我在配置过程中踩到的一些坑:\"></a>以下是我在配置过程中踩到的一些坑:</h3><ol>\n<li>8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；</li>\n<li>git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；</li>\n</ol>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png\" alt=\"\"></p>\n<p>接下来，其他用户直接通过浏览器登录 <a href=\"http://192.168.0.xxx:8082\" target=\"_blank\" rel=\"noopener\">http://192.168.0.xxx:8082</a> ，通过账号密码登录，便可以配置和构建项目。</p>\n<h3 id=\"jenkins相对Mac-OS-Server的优点\"><a href=\"#jenkins相对Mac-OS-Server的优点\" class=\"headerlink\" title=\"jenkins相对Mac OS Server的优点:\"></a>jenkins相对Mac OS Server的优点:</h3><ol>\n<li>同一局域网便可以登录，登录之后便可以自行配置项目</li>\n<li>似乎可以并行构建任务</li>\n</ol>\n<p>当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png\" alt=\"\"><br>而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png\" alt=\"\"><br>这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。</p>\n<p>但是jenkins有更方便的打包方式:<br>jenkins开启token，不需要用户名登录便可以打包:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png\" alt=\"\"></p>\n<p>这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。<br>系统管理-&gt;全局安全配置-&gt;勾选 Allow anonymous read access<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png\" alt=\"\"></p>\n<p>接着，我们便可以通过命令来打包:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&amp;cause\\=testBuild</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>notification_extension_test</td>\n<td style=\"text-align:right\">项目名称</td>\n</tr>\n<tr>\n<td>token</td>\n<td style=\"text-align:right\">上面设置的token</td>\n</tr>\n<tr>\n<td>cause</td>\n<td style=\"text-align:right\">可选参数，可不传</td>\n</tr>\n</tbody>\n</table>\n<p>这样似乎可以用一台服务器，将打包任务部署到指定机器上:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png\" alt=\"\"><br>这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。</p>\n<h2 id=\"关于Server和jenkins的一些总结\"><a href=\"#关于Server和jenkins的一些总结\" class=\"headerlink\" title=\"关于Server和jenkins的一些总结:\"></a>关于Server和jenkins的一些总结:</h2><ol>\n<li>如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；</li>\n<li>对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；</li>\n<li>如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。</li>\n</ol>\n<h2 id=\"fastlane及打包脚本简单介绍\"><a href=\"#fastlane及打包脚本简单介绍\" class=\"headerlink\" title=\"fastlane及打包脚本简单介绍\"></a>fastlane及打包脚本简单介绍</h2><p>说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:</p>\n<ol>\n<li>避免繁琐的路径拼接，拷贝等</li>\n<li>修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败</li>\n</ol>\n<p>我们来简单看一段fastlane的打包代码:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png\" alt=\"\"></p>\n<p>上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane adhocMyApp version:100000  // 100000是传的版本号</span><br></pre></td></tr></table></figure>\n<p>便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png\" alt=\"\"></p>\n<p>发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png\" alt=\"\"></p>\n<p>我们再看终端，看看fastlane究竟做了些啥<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png\" alt=\"\"></p>\n<p>也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对应手动打包archive</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationRelease&#125; -archivePath $&#123;archivePath&#125;</span><br><span class=\"line\">// 对应导出步骤</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archivePath&#125; -exportPath $&#123;exportPath&#125; -exportOptionsPlist $&#123;exportOptionsPlist&#125;</span><br></pre></td></tr></table></figure>\n<p>上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。</p>\n<p>经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>说到自动化打包，相信大家在日常开发中都有所接触，尤其是在多分支并行开发的情况下，自动化打包显得尤为重要，很多时候，我们打包一般是打及成分支的包，开发却在开发分支上，如果采取手动打包，我们需要反复切分支，不仅影响工作效率，而且会打断我们的开发思维，而却在工程较大的情况下，xcode每次indexing需要的时间就很久。</p>\n<p>即使对于很多单分支开发的小项目来说，自动化打 包的优势也是不言而喻的，因为在手动打包的同时，基本可以说是什么事都做不了的，你需要一步步等待archive，export这些机械化的步骤。而有了自动化打包，你只需要点击一个按钮，便可以继续自己的开发。所以，自动化打包势在必行。</p>\n<p>本文主要记录了我在公司自动化打包布置中的一些探索，及各平台的优缺点和配置过程踩过的坑。</p>\n<p>谈到iOS的持续集成，我们首先想到的一定会是jenkins，这里我先介绍下我司采用的Mac OS Server(以下简称Server)这个平台的一些优缺点。</p>\n<h2 id=\"Server相比于jenkins，我总结优点有三\"><a href=\"#Server相比于jenkins，我总结优点有三\" class=\"headerlink\" title=\"Server相比于jenkins，我总结优点有三:\"></a>Server相比于jenkins，我总结优点有三:</h2><ol>\n<li>相比于jenkins的各种繁琐配置，Server配置简单，全程基本下一步操作即可；</li>\n<li>直接使用xcode就可开始构建项目，而不需要登录网页；</li>\n<li>集成度相当高，没有特别的需求，基本可以不写脚本，只需要配置一个plist文件即可以打包。</li>\n</ol>\n<p>这里不做过多的配置介绍，虽然Server没有jenkins热门，但网上的文章也比比皆是，而且如上优点1中所说，Server配置真的很简单，在证书、描述文件齐全的情况下，基本就是一直点下一步操作。</p>\n<p>下面我介绍使用过程中需要注意的一些方面: </p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_integration.png\" alt=\"\"></p>\n<p>如上图所示，上图是对bot的各种设置，一个bot对应一个独立工作空间，如果有了解jenkins的话，bot可以类比jenkins的一个项目。</p>\n<p>如果对打包没有特别需求，勾选Archive，选择对应Scheme、Configuration，指定一个plist文件，后面的Triggers不需要写任何代码，便可以打出对应的包。</p>\n<p>上面所说的plist文件大体结构是这样的:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/exportPlist.png\" alt=\"\"></p>\n<p>这个plist文件对应一系列的参数，并不需要我们自己写，手动打一次包，即可导出这个文件。这里顺便提一句，Server配置好后，连接此Server后，任意机器都可以上传此plist文件，Server是将上传的plist文件拷贝到当前Bot工作目录下。</p>\n<p>在Server配置好后，即使是windows电脑也可以通过ip或者自签证书登录，<br><a href=\"https://192.168.0.xxx/xcode/lastest\" target=\"_blank\" rel=\"noopener\">https://192.168.0.xxx/xcode/lastest</a> 或 <a href=\"https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。\" target=\"_blank\" rel=\"noopener\">https://xxxdemac-mini.local/xcode/bots/latest，登陆后会显示以下界面，点击integration，便可以开始集成了，但是这里似乎只能够集成，不能配置，不过根据Apple的惯性，想要构造自己的生态，我们也是能理解的。</a><br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcode_page.png\" alt=\"\"></p>\n<h2 id=\"关于jenkins的一些配置注意事项\"><a href=\"#关于jenkins的一些配置注意事项\" class=\"headerlink\" title=\"关于jenkins的一些配置注意事项:\"></a>关于jenkins的一些配置注意事项:</h2><h3 id=\"以下是我在配置过程中踩到的一些坑\"><a href=\"#以下是我在配置过程中踩到的一些坑\" class=\"headerlink\" title=\"以下是我在配置过程中踩到的一些坑:\"></a>以下是我在配置过程中踩到的一些坑:</h3><ol>\n<li>8080端口被其他程序占用，启动失败: java -jar jenkins.war —httpPort=8082；</li>\n<li>git权限需要告诉jenkins私钥，而不是git上的公钥: cat ~/.ssh/id_rsa；</li>\n</ol>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_rsa.png\" alt=\"\"></p>\n<p>接下来，其他用户直接通过浏览器登录 <a href=\"http://192.168.0.xxx:8082\" target=\"_blank\" rel=\"noopener\">http://192.168.0.xxx:8082</a> ，通过账号密码登录，便可以配置和构建项目。</p>\n<h3 id=\"jenkins相对Mac-OS-Server的优点\"><a href=\"#jenkins相对Mac-OS-Server的优点\" class=\"headerlink\" title=\"jenkins相对Mac OS Server的优点:\"></a>jenkins相对Mac OS Server的优点:</h3><ol>\n<li>同一局域网便可以登录，登录之后便可以自行配置项目</li>\n<li>似乎可以并行构建任务</li>\n</ol>\n<p>当使用Mac OS Server进行打包，无论进行多少个打包任务，它只开启一个xcodebuild进程<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_server.png\" alt=\"\"><br>而使用jenkins进行多项目打包，这里开始构建两个项目就开启两个进程(下图上面两个xcodebuild进程是jenkins开启)<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/xcodebuild_process_jenkins.png\" alt=\"\"><br>这里我没有做定量的测试，猜想是jenkins的效率稍优，对于多核处理器，相同的计算能力，对于两个构建来说，应该没多大差距，但对于拉代码等耗时操作，比起Server其他构建任务在排队，这部分就能省上一些时间。</p>\n<p>但是jenkins有更方便的打包方式:<br>jenkins开启token，不需要用户名登录便可以打包:</p>\n<p><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_token.png\" alt=\"\"></p>\n<p>这样给构建项目设置后还是不行的，因为jenkins觉得这样是不安全的，拿到了token就可以做任何事了。<br>系统管理-&gt;全局安全配置-&gt;勾选 Allow anonymous read access<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_allow_anonymous_read_access.png\" alt=\"\"></p>\n<p>接着，我们便可以通过命令来打包:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl http://10.24.113.24:8082/job/notification_extension_test/build\\?token\\=123\\&amp;cause\\=testBuild</span><br></pre></td></tr></table></figure></p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">注释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>notification_extension_test</td>\n<td style=\"text-align:right\">项目名称</td>\n</tr>\n<tr>\n<td>token</td>\n<td style=\"text-align:right\">上面设置的token</td>\n</tr>\n<tr>\n<td>cause</td>\n<td style=\"text-align:right\">可选参数，可不传</td>\n</tr>\n</tbody>\n</table>\n<p>这样似乎可以用一台服务器，将打包任务部署到指定机器上:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/jenkins_servers.png\" alt=\"\"><br>这样可以在一台机器上集成公司不同端的项目，而且还不影响打包效率。</p>\n<h2 id=\"关于Server和jenkins的一些总结\"><a href=\"#关于Server和jenkins的一些总结\" class=\"headerlink\" title=\"关于Server和jenkins的一些总结:\"></a>关于Server和jenkins的一些总结:</h2><ol>\n<li>如果仅仅是iOS端的打包，Server是完全够用了，而且操作贴近我们平时的开发风格，虽然网页无法配置，但是对于大部分公司来说，打包配置都是开发在做的，而不是测试；</li>\n<li>对于iOS端小型项目来说，没有特别多的分支，直接可以多建几个bot，从而避开手写脚本；</li>\n<li>如果多端同一服务器，那么jenkins无疑有较大的优势；如果公司有足够的电脑作为分布打包服务器，那么打包效率会更上一层楼。</li>\n</ol>\n<h2 id=\"fastlane及打包脚本简单介绍\"><a href=\"#fastlane及打包脚本简单介绍\" class=\"headerlink\" title=\"fastlane及打包脚本简单介绍\"></a>fastlane及打包脚本简单介绍</h2><p>说到自动化打包，就不得不谈当下非常流行的fastlane，如果说Server和jenkins是同一维度的，都是打包平台，那么fastlane应该是和shell脚本来作比较，或者可以说，fastlane是在shell的基础上封装了一层，fastlane相比于脚本打包，短暂体验后，我觉得优点主要有:</p>\n<ol>\n<li>避免繁琐的路径拼接，拷贝等</li>\n<li>修改工程配置文件，避免调试时修改配置文件不小心提交到远程分支，导致打包失败</li>\n</ol>\n<p>我们来简单看一段fastlane的打包代码:<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_demo.png\" alt=\"\"></p>\n<p>上述代码参数基本见名知意，不难看出，这基本就是给之前Server的exportPlist文件的一种包装，只需执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fastlane adhocMyApp version:100000  // 100000是传的版本号</span><br></pre></td></tr></table></figure>\n<p>便可以自动打出一个包，并导出dSYM文件，这里我故意把Distribution的provisioning Profile改成企业的<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_configuration.png\" alt=\"\"></p>\n<p>发现工程配置文件发生了改变，这里比较暴力，把每种configuration的Provisioning Profile和teamID全都改了<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_change_configuration.png\" alt=\"\"></p>\n<p>我们再看终端，看看fastlane究竟做了些啥<br><img src=\"http://p28r7eh75.bkt.clouddn.com/%E5%85%B3%E4%BA%8EiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%86%E4%BA%AB/fastlane_temernal.png\" alt=\"\"></p>\n<p>也确实和上图一样，把所有都改成了AdHoc的。在进行修改配置后，最终也是执行打包的核心脚本:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 对应手动打包archive</span><br><span class=\"line\">xcodebuild archive -workspace $&#123;work_space&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configurationRelease&#125; -archivePath $&#123;archivePath&#125;</span><br><span class=\"line\">// 对应导出步骤</span><br><span class=\"line\">xcodebuild -exportArchive -archivePath $&#123;archivePath&#125; -exportPath $&#123;exportPath&#125; -exportOptionsPlist $&#123;exportOptionsPlist&#125;</span><br></pre></td></tr></table></figure>\n<p>上述脚本的参数也基本见名知意，脚本中${work_space}等代表取一个变量的值，这里都是各个配置对应的路径或字符串。</p>\n<p>经历上述脚本后，就会在指定的exportPath路径下生成.ipa文件。我们一般是要将ipa和dSYM文件copy到指定的文件夹供测试去取，后面便是一段处理繁琐的路径的脚本，脚本本身没任何难度，但是要格外注意，且测试起来需要花费一定的时间，如果使用fastlane就可以避免这个烦恼。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要是团队中的一次分享后的整理，并不是特别细致的教程，只是对当下的自动化打包的一些尝试及过程中遇到的一些问题和自己的一点思考，如果有说的不对的地方，望不吝赐教。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}